var searchIndex = {};
searchIndex['nphysics'] = {"items":[[0,"","nphysics","nphysics\n========\n**nphysics** is a 2 and 3-dimensional physics engine for games and animations. It uses\n[ncollide](http://ncollide.org) for collision detection, and\n[nalgebra](http://nalgebra.org) for vector/matrix math."],[0,"aliases","","Aliases for complicated parameterized types."],[4,"DefaultBroadPhase","nphysics::aliases","The type of the broad phase used by the world by default."],[0,"integration","nphysics","Position and orientation update of rigid bodies."],[1,"BodyExpEulerIntegrator","nphysics::integration","An explicit Euler integrator."],[1,"BodySmpEulerIntegrator","","A semi-implicit Euler integrator."],[1,"BodyForceGenerator","","A constant linear and angular force generator."],[1,"BodyDamping","","A linear and angular velocity damper."],[1,"TranslationalCCDMotionClamping","","Handles Continuous Collision Detection."],[0,"integrator","","Trait implemented by every integrators."],[6,"Integrator","nphysics::integration::integrator","Trait implemented by every integrator."],[9,"update","","Updates the position and orientation of the object `o` after a time step of `dt`.",0],[10,"new","nphysics::integration","Creates a new `BodyExpEulerIntegrator`.",1],[10,"update","","",1],[10,"new","","Creates a new `BodySmpEulerIntegrator`.",2],[10,"update","","",2],[10,"new","","Creates a new `BodyForceGenerator`.",3],[10,"lin_acc","","The linear acceleration applied by this force generator.",3],[10,"set_lin_acc","","Sets the linear acceleration applied by this force generator.",3],[10,"ang_acc","","The angular acceleration applied by this force generator.",3],[10,"set_ang_acc","","Sets the angular acceleration applied by this force generator.",3],[10,"update","","",3],[10,"new","","Creates a new `BodyDamping`.",4],[10,"update","","",4],[10,"new","","Creates a new `TranslationalCCDMotionClamping` to enable continuous collision detection to\nfast-moving rigid bodies.",5],[10,"add_ccd_to","","Enables continuous collision for the given rigid body.",5],[10,"remove_ccd_from","","Remove continuous collision from the given rigid body.",5],[10,"update","","Update the time of impacts and apply motion clamping when necessary.",5],[0,"euler","","Euler integration functions."],[3,"explicit_integrate","nphysics::integration::euler","Explicit Euler integrator."],[3,"explicit_integrate_wo_rotation","","Explicit Euler integrator. This will not update the rotational components."],[3,"semi_implicit_integrate","","Semi-implicit Euler integrator."],[3,"semi_implicit_integrate_wo_rotation","","Semi-implicit Euler integrator. This will not update the rotational components."],[3,"displacement","","Computes the transformation matrix required to move an object with a `lin_vel` linear velocity,\na `ang_vil` angular velocity, and a center of mass `center_of_mass`, during the time step `dt`."],[0,"detection","nphysics","Collision detection and joints."],[1,"ActivationManager","nphysics::detection","Structure that monitors island-based activation/deactivation of objects."],[0,"constraint","","Data structure to describe a constraint between two rigid bodies."],[2,"Constraint","nphysics::detection::constraint","A constraint between two rigid bodies."],[12,"RBRB","","A contact.",6],[12,"BallInSocket","","A ball-in-socket joint.",6],[12,"Fixed","","A fixed joint.",6],[10,"clone","","",6],[0,"detector","nphysics::detection","Collision detector."],[6,"Detector","nphysics::detection::detector","Trait implemented by collision detectors."],[9,"update","","Updates the collision detector, given an (already updated) broad-phase, and an activation\nmanager.",7],[9,"interferences","","Collects every interferences detected by this collision detector.",7],[0,"joint","nphysics::detection","Joint handling."],[1,"Anchor","nphysics::detection::joint","One of the two end points of a joint."],[11,"body","","The body attached to this anchor.",8],[11,"position","","The attach position, in local coordinates of the attached body.",8],[1,"BallInSocket","","A ball-in-socket joint."],[1,"Fixed","","A joint that prevents any relative movement (linear and angular) between two objects."],[1,"JointManager","","Structure that handles creation and removal of joints."],[10,"new","","Creates a new `JointManager`.",9],[10,"joints","","Joints handled by this manager.",9],[10,"joints_with_body","","List of joints attached to a specific body.",9],[10,"add_ball_in_socket","","Add a `BallInSocket` joint to this manager.",9],[10,"remove_ball_in_socket","","Removes a `BallInSocket` joint from this manager.",9],[10,"add_fixed","","Add a `Fixed` joint to this manager.",9],[10,"remove_joint","","Removes a joint from this manager.",9],[10,"remove","","Removes every joint attached to a given rigid body.",9],[10,"update","","Activates the objects that interact with an activated object through a joint.",9],[10,"interferences","","Collects all the constraints caused by joints.",9],[10,"new","","Creates a new `Anchor` at a given `position` on a `body` local space.",8],[10,"center_of_mass","","The center of mass of the body attached to this anchor.",8],[10,"new","","Creates a ball-in-socket joint.",10],[10,"up_to_date","","Tells if this joint has been modified by the user.",10],[10,"set_local1","","Sets the the second anchor position.",10],[10,"set_local2","","Sets the the second anchor position.",10],[10,"anchor1","","The first anchor affected by this joint.",10],[10,"anchor2","","The second anchor affected by this joint.",10],[10,"anchor1_pos","","The first attach point in global coordinates.",10],[10,"anchor2_pos","","The second attach point in global coordinates.",10],[10,"new","","Creates a new `Fixed` joint.",11],[10,"up_to_date","","Tells if the joint has been modified by the user.",11],[10,"set_local1","","Sets the the second anchor position.",11],[10,"set_local2","","Sets the the second anchor position.",11],[10,"anchor1","","The first anchor affected by this joint.",11],[10,"anchor2","","The second anchor affected by this joint.",11],[10,"anchor1_pos","","The first attach point in global coordinates.",11],[10,"anchor2_pos","","The second attach point in global coordinates.",11],[0,"joint","",""],[6,"Joint","nphysics::detection::joint::joint","Trait implemented by every joint."],[9,"anchor1","","The first anchor affected by this joint.",12],[9,"anchor2","","The second anchor affected by this joint.",12],[9,"anchor1_pos","","The first attach point in global coordinates.",12],[9,"anchor2_pos","","The second attach point in global coordinates.",12],[10,"new","nphysics::detection","Creates a new `ActivationManager`.",13],[10,"will_activate","","Notify the `ActivationManager` that is has to activate an object at the next update.",13],[10,"update","","Update the activation manager, activating and deactivating objects when needed.",13],[0,"resolution","nphysics","Constraint resolution."],[1,"AccumulatedImpulseSolver","nphysics::resolution","Constraint solver using the projected gauss seidel algorithm and warm-starting."],[1,"Velocities","","Structure holding the result of the projected gauss seidel solver."],[11,"lv","","Linear velocity.",14],[11,"av","","Angular velocity.",14],[1,"ImpulseCache","",""],[1,"ContactIdentifier","","The identifier of a contact stored in the impulse cache."],[1,"VelocityConstraint","","A constraint of velocity at a point of contact."],[11,"normal","","The contact normal.",15],[11,"weighted_normal1","","The contact normal multiplied by the first body's inverse mass.",15],[11,"weighted_normal2","","The contact normal multiplied by the second body's inverse mass.",15],[11,"rot_axis1","","The first body rotation axis.",15],[11,"weighted_rot_axis1","","The first body rotation axis multiplied by its inverse inertia.",15],[11,"rot_axis2","","The second body rotation axis.",15],[11,"weighted_rot_axis2","","The second body rotation axis multiplied by its inverse inertia.",15],[11,"inv_projected_mass","","The inverse of the sum of linear and angular inertia of both bodies.",15],[11,"impulse","","The total impulse applied.",15],[11,"lobound","","The lower bound of the impulse.",15],[11,"hibound","","The upper bound of the impulse.",15],[11,"objective","","The target delta velocity.",15],[11,"id1","","The id of the first body.",15],[11,"id2","","The id of the second body.",15],[11,"friction_limit_id","","The id of the friction constraint.",15],[11,"friction_coeff","","The friction coefficient on this contact.",15],[2,"CorrectionMode","","The correction coefficient used by the constraint solver."],[12,"Velocity","","Penetration are solved by the penalty method.",16],[12,"VelocityAndPosition","","Penetration are solved by the penalty method together with a hard repositioning.",16],[12,"VelocityAndPositionThresold","","Penetration are solved by the penalty method together with a hard repositioning.",16],[3,"projected_gauss_seidel_solve","","Solve a set of velocity constraints using the projected gauss seidel solver."],[0,"solver","",""],[6,"Solver","nphysics::resolution::solver","Trait implemented by constraint solvers."],[9,"solve","","Solve the set of constraints of type `I`.",17],[10,"new","nphysics::resolution","Creates a new `AccumulatedImpulseSolver`.",18],[10,"num_first_order_iter","","Gets the number of iteration done by the penetration depth correction solver.",18],[10,"set_num_first_order_iter","","Sets the number of iteration done by the penetration depth correction solver.",18],[10,"num_second_order_iter","","Gets the number of iteration done by the velocity constraint solver.",18],[10,"set_num_second_order_iter","","Sets the number of iteration done by the velocity constraint solver.",18],[10,"solve","","",18],[10,"clone","","",14],[10,"fmt","","",14],[10,"eq","","",14],[10,"ne","","",14],[10,"new","","Creates a new `Velocities`.",14],[10,"reset","","Reset this structure to zero.",14],[10,"clone","","",15],[10,"fmt","","",15],[10,"eq","","",15],[10,"ne","","",15],[10,"new","","Creates a new velocity constraint with all terms initialized to zero.",15],[10,"vel_corr_factor","","The velocity correction coefficient.",16],[10,"pos_corr_factor","","The position correction coefficient.",16],[10,"min_depth_for_pos_corr","","The minimum penetration depth required to switch on the hard repositioning based method.",16],[10,"max_depth_for_vel_corr","","The max penetration depth the velocity correction will attempt to correct.",16],[0,"world","nphysics","The physics world."],[1,"World","nphysics::world","The physics world."],[10,"new","","Creates a new physics world.",19],[10,"step","","Updates the physics world.",19],[10,"add_body","","Adds a rigid body to the physics world.",19],[10,"remove_body","","Remove a rigid body from the physics world.",19],[10,"forces_generator","","Gets a mutable reference to the force generator.",19],[10,"integrator","","Gets a mutable reference to the position and orientation integrator.",19],[10,"collision_world","","Gets a mutable reference to the collision detector.",19],[10,"ccd_manager","","Gets a mutable reference to the CCD manager.",19],[10,"joint_manager","","Gets a mutable reference to the joint manager.",19],[10,"constraints_solver","","Gets a mutable reference to the constraint solver.",19],[10,"set_gravity","","Sets the linear acceleration afecting every dynamic rigid body.",19],[10,"set_angular_acceleration","","Sets the angular acceleration afecting every dynamic rigid body.",19],[10,"gravity","","Gets the linear acceleration afecting every dynamic rigid body.",19],[10,"angular_acceleration","","Gets the angular acceleration afecting every dynamic rigid body.",19],[10,"interferences_with_ray","","Gets every body intersected by a given ray.",19],[10,"interferences_with_point","","Gets every body that contain a specific point.",19],[10,"interferences_with_aabb","","Gets every body that intersects a specific AABB.",19],[10,"add_ccd_to","","Adds continuous collision detection to the given rigid body.",19],[10,"add_ball_in_socket","","Adds a ball-in-socket joint to the world.",19],[10,"remove_ball_in_socket","","Removes a ball-in-socket joint from the world.",19],[10,"add_fixed","","Adds a fixed joint to the world.",19],[10,"remove_fixed","","Removes a fixed joint from the world.",19],[10,"interferences","","Collects every interferences detected since the last update.",19],[10,"bodies","","An iterator visiting all rigid bodies on this world.",19],[10,"register_contact_signal_handler","","Registers a handler for contact start/stop events.",19],[10,"unregister_contact_signal_handler","","Unregisters a handler for contact start/stop events.",19],[4,"WorldBroadPhase","","The default broad phase."],[4,"RigidBodyCollisionWorld","","Type of the collision world containing rigid bodies."],[0,"object","nphysics","Rigid bodies."],[1,"RigidBody","nphysics::object","The rigid body structure."],[2,"ActivationState","","The activation state of a rigid body."],[12,"Active","","The rigid body is active with a not-zero energy.",20],[12,"Inactive","","The rigid body is inactive.",20],[12,"Deleted","","The rigid body has been removed from the physics engine.",20],[2,"RigidBodyState","","The movement state of a rigid body."],[12,"Static","","The rigid body cannot move.",21],[12,"Dynamic","","The rigid body can move.",21],[10,"decode","","",21],[10,"encode","","",21],[10,"clone","","",21],[10,"eq","","",21],[10,"ne","","",21],[10,"fmt","","",21],[10,"decode","","",20],[10,"encode","","",20],[10,"clone","","",20],[10,"eq","","",20],[10,"ne","","",20],[10,"fmt","","",20],[10,"energy","","The energy accumulated other several frames.",20],[10,"clone","","",22],[10,"position","","Gets a reference to this body's transform.",22],[10,"shape_ref","","Gets a reference to this body's shape.",22],[10,"shape","","Gets a copy of this body's shared shape.",22],[10,"margin","","The margin surrounding this object's shape.",22],[10,"center_of_mass","","Gets a reference to this body's center of mass.",22],[10,"restitution","","Gets this body's restitution coefficent.",22],[10,"friction","","Gets this body's friction coefficient.",22],[10,"is_active","","Indicates whether or not this rigid body is active.",22],[10,"deactivation_threshold","","The velocity threshold bellow whith the rigid body might be deactivated.",22],[10,"set_deactivation_threshold","","Set the velocity threshold bellow whith the rigid body might be deactivated.",22],[10,"new_dynamic","","Creates a new rigid body that can move.",22],[10,"new_static","","Creates a new rigid body that cannot move.",22],[10,"new","","Creates a new rigid body with a given shape.",22],[10,"collision_groups","","The collision groups this rigid body is part of.",22],[10,"can_move","","Indicates whether this rigid body is static or dynamic.",22],[10,"lin_acc_scale","","Gets the linear acceleraction scale of this rigid body.",22],[10,"set_lin_acc_scale","","Sets the linear acceleration scale of this rigid body.",22],[10,"ang_acc_scale","","Gets the angular acceleration scale of this rigid body.",22],[10,"set_ang_acc_scale","","Sets the angular acceleration scale of this rigid body.",22],[10,"lin_vel","","Get the linear velocity of this rigid body.",22],[10,"set_lin_vel","","Sets the linear velocity of this rigid body.",22],[10,"lin_acc","","Gets the linear acceleration of this rigid body.",22],[10,"set_lin_acc","","Sets the linear acceleration of this rigid body.",22],[10,"ang_vel","","Gets the angular velocity of this rigid body.",22],[10,"set_ang_vel","","Sets the angular velocity of this rigid body.",22],[10,"ang_acc","","Gets the angular acceleration of this rigid body.",22],[10,"set_ang_acc","","Sets the angular acceleration of this rigid body.",22],[10,"inv_mass","","Gets the inverse mass of this rigid body.",22],[10,"set_inv_mass","","Sets the inverse mass of this rigid body.",22],[10,"inv_inertia","","Gets the inverse inertia tensor of this rigid body.",22],[10,"set_inv_inertia","","Sets the inverse inertia tensor of this rigid body.",22],[10,"append_transformation","","Appends a transformation to this rigid body.",22],[10,"prepend_transformation","","Prepends a transformation to this rigid body.",22],[10,"set_transformation","","Sets the transformation of this rigid body.",22],[10,"append_translation","","Appends a translation to this rigid body.",22],[10,"prepend_translation","","Prepends a translation to this rigid body.",22],[10,"set_translation","","Stes the translation of this rigid body.",22],[10,"append_rotation","","Appends a rotation to this rigid body.",22],[10,"prepend_rotation","","Prepends a rotation to this rigid body.",22],[10,"set_rotation","","Sets the rotation of this rigid body.",22],[10,"bounding_volume","","",22],[10,"bounding_volume","alloc::rc","",23],[4,"RigidBodyHandle","nphysics::object","A shared, mutable, rigid body."],[0,"utils","nphysics","Miscellaneous utilities."],[0,"union_find","nphysics::utils","The union find algorithm."],[1,"UnionFindSet","nphysics::utils::union_find","An element used by the union-find algorithm."],[3,"find","","Performs the `find` part of the union-find algorithm."],[3,"union","","Performs the `union` part of the union-find algorithm."],[10,"clone","","",24],[10,"new","","Creates a new `UnionFindSet`.",24],[10,"reinit","","Reinitialize this set.",24],[0,"volumetric","nphysics","Volume and inertia tensor computation."],[3,"ball_volume","nphysics::volumetric","The volume of a ball."],[3,"ball_surface","","The surface of a ball."],[3,"ball_center_of_mass","","The center of mass of a ball."],[3,"ball_unit_angular_inertia","","The unit angular inertia of a ball."],[3,"cylinder_volume","","The volume of a cylinder."],[3,"cylinder_surface","","The surface of a cylinder."],[3,"cylinder_center_of_mass","","The center of mass of a cylinder."],[3,"cylinder_unit_angular_inertia","","The unit angular inertia of a cylinder."],[3,"cone_volume","","The volume of a cone."],[3,"cone_surface","","The surface of a cone."],[3,"cone_center_of_mass","","The center of mass of a cone."],[3,"cone_unit_angular_inertia","","The unit angular inertia of a cone."],[3,"cuboid_volume","","The volume of a cuboid."],[3,"cuboid_surface","","The surface of a cuboid."],[3,"cuboid_center_of_mass","","The center of mass of a cuboid."],[3,"cuboid_unit_angular_inertia","","The unit angular inertia of a cuboid."],[3,"convex_mesh_surface","","The surface of a convex mesh."],[3,"convex_mesh_volume_and_center_of_mass","","The volume and center of mass of a convex mesh."],[3,"convex_mesh_mass_properties","","The mass properties of a convex mesh."],[3,"convex_hull_surface","","The surface of a convex hull."],[3,"convex_hull_volume","","The volume of the convex hull of a set of points."],[3,"convex_hull_center_of_mass","","The center of mass of the convex hull of a set of points."],[3,"convex_hull_unit_angular_inertia","","The angular inertia of the convex hull of a set of points."],[10,"surface","nphysics::volumetric::volumetric_ball","",25],[10,"volume","","",25],[10,"center_of_mass","","",25],[10,"unit_angular_inertia","","",25],[10,"surface","","",26],[10,"volume","","",26],[10,"center_of_mass","","",26],[10,"unit_angular_inertia","","",26],[10,"surface","nphysics::volumetric::volumetric_cylinder","",27],[10,"volume","","",27],[10,"center_of_mass","","",27],[10,"unit_angular_inertia","","",27],[10,"surface","","",28],[10,"volume","","",28],[10,"center_of_mass","","",28],[10,"unit_angular_inertia","","",28],[10,"surface","nphysics::volumetric::volumetric_cuboid","",29],[10,"volume","","",29],[10,"center_of_mass","","",29],[10,"unit_angular_inertia","","",29],[10,"surface","","",30],[10,"volume","","",30],[10,"center_of_mass","","",30],[10,"unit_angular_inertia","","",30],[10,"surface","nphysics::volumetric::volumetric_cone","",31],[10,"volume","","",31],[10,"center_of_mass","","",31],[10,"unit_angular_inertia","","",31],[10,"surface","","",32],[10,"volume","","",32],[10,"center_of_mass","","",32],[10,"unit_angular_inertia","","",32],[10,"surface","nphysics::volumetric::volumetric_compound","",33],[10,"volume","","",33],[10,"center_of_mass","","",33],[10,"unit_angular_inertia","","",33],[10,"mass_properties","","The mass properties of this `CompoundData`.",33],[10,"surface","","",34],[10,"volume","","",34],[10,"center_of_mass","","",34],[10,"unit_angular_inertia","","",34],[10,"mass_properties","","The mass properties of this `CompoundData`.",34],[10,"surface","nphysics::volumetric::volumetric_convex","",35],[10,"volume","","",35],[10,"center_of_mass","","",35],[10,"unit_angular_inertia","","",35],[10,"mass_properties","","",35],[10,"surface","nphysics::volumetric","",36],[10,"volume","","",36],[10,"center_of_mass","","",36],[10,"unit_angular_inertia","","",36],[10,"mass_properties","","",36],[10,"surface","","",36],[10,"volume","","",36],[10,"center_of_mass","","",36],[10,"unit_angular_inertia","","",36],[10,"mass_properties","","",36],[6,"Volumetric","","Trait implemented by objects which have a mass, a center of mass, and an inertia tensor."],[9,"surface","","Computes the surface of this object.",37],[9,"volume","","Computes the volume of this object.",37],[9,"center_of_mass","","Computes the center of mass of this object.",37],[9,"unit_angular_inertia","","Computes the angular inertia tensor of this object.",37],[10,"mass","","Given its density, this computes the mass of this object.",37],[10,"angular_inertia","","Given its mass, this computes the angular inertia of this object.",37],[10,"mass_properties","","Given its density, this computes the mass, center of mass, and inertia tensor of this object.",37],[6,"InertiaTensor","","Trait implemented by inertia tensors."],[9,"apply","","Applies this inertia tensor to a vector.",38],[9,"to_world_space","","Transforms this inertia tensor from local space to world space.",38],[9,"to_relative_wrt_point","","Computes this inertia tensor relative to a given point.",38],[0,"math","nphysics","Compilation flags dependent aliases for mathematical types."],[4,"Scalar","nphysics::math","The scalar type."],[4,"Point","","The point type."],[4,"Vect","","The vector type."],[4,"Orientation","","The orientation type."],[4,"Matrix","","The transformation matrix type."],[4,"RotationMatrix","","The rotation matrix type."],[4,"AngularInertia","","The inertia tensor type."]],"paths":[[6,"Integrator"],[1,"BodyExpEulerIntegrator"],[1,"BodySmpEulerIntegrator"],[1,"BodyForceGenerator"],[1,"BodyDamping"],[1,"TranslationalCCDMotionClamping"],[2,"Constraint"],[6,"Detector"],[1,"Anchor"],[1,"JointManager"],[1,"BallInSocket"],[1,"Fixed"],[6,"Joint"],[1,"ActivationManager"],[1,"Velocities"],[1,"VelocityConstraint"],[2,"CorrectionMode"],[6,"Solver"],[1,"AccumulatedImpulseSolver"],[1,"World"],[2,"ActivationState"],[2,"RigidBodyState"],[1,"RigidBody"],[1,"Rc"],[1,"UnionFindSet"],[4,"Ball2"],[4,"Ball3"],[4,"Cylinder2"],[4,"Cylinder3"],[4,"Cuboid2"],[4,"Cuboid3"],[4,"Cone2"],[4,"Cone3"],[4,"Compound2"],[4,"Compound3"],[4,"Convex3"],[6,"Repr"],[6,"Volumetric"],[6,"InertiaTensor"]]};
searchIndex['ncollide'] = {"items":[[0,"","ncollide","ncollide\n========"],[0,"math","",""],[6,"Scalar","ncollide::math","Trait implemented by scalar types."],[6,"Point","","Trait implemented by point types."],[6,"Vect","","Trait implemented by vector types."],[6,"Isometry","","Trait implemented by transformation matrices types."],[6,"HasInertiaMatrix","","Trait implement by vectors that are transformable by the inertia matrix `I`."],[0,"utils","ncollide",""],[0,"data","ncollide::utils","Data structure utilities."],[0,"pair","ncollide::utils::data","Hashable pair of objects implementing `HasUid`."],[10,"new","ncollide_utils::data::pair","Builds a new `Pair`.",0],[10,"decode","","",0],[10,"encode","","",0],[10,"clone","","",0],[10,"clone_from","","",0],[10,"eq","","",0],[10,"ne","","",0],[10,"decode","","",1],[10,"encode","","",1],[10,"new","","Creates a new PairTWHash",1],[10,"hash","","",1],[10,"decode","ncollide_utils::data::hash","",2],[10,"encode","","",2],[10,"clone","","",2],[10,"clone_from","","",2],[10,"new","","Creates a new UintPairTWHash.",2],[10,"hash","","",2],[10,"decode","","",3],[10,"encode","","",3],[10,"clone","","",3],[10,"clone_from","","",3],[10,"new","","Creates a new UintTWHash.",3],[10,"hash","","",3],[10,"decode","ncollide_utils::data::hash_map","",4],[10,"encode","","",4],[10,"clone","","",4],[10,"clone_from","","",4],[10,"decode","","",5],[10,"encode","","",5],[10,"clone","","",5],[10,"clone_from","","",5],[10,"new","","Creates a new hash map.",5],[10,"new_with_capacity","","Creates a new hash map with a given capacity.",5],[10,"elements","","The elements added to this hash map.",5],[10,"elements_mut","","The elements added to this hash map.",5],[10,"len","","The number of elements contained by this hashmap.",5],[10,"is_empty","","Whether or not this hashmap is empty.",5],[10,"clear","","Removes everything from this hashmap.",5],[10,"remove_elem_at","","Removes the element at the specified position of the element array.",5],[10,"get_and_remove","","Removes an element and returns its value if it existed.",5],[10,"find_or_insert_lazy","","Same as `self.insert_or_replace(key, value, false)` but with `value` a function which is\ncalled iff. the value does not exist yet. If the functions returns `None`, nothing is\ninserted.",5],[10,"insert_or_replace","","Inserts or replace an element.",5],[10,"contains_key","","Checks whether this hashmap contains a specific key.",5],[10,"find","","Finds a reference to the element with a given key.",5],[10,"insert","","Inserts an element on the hash map.",5],[10,"remove","","Remove an element from the hash map.",5],[10,"find_mut","","Gets a mutable reference to an element of the hashmap.",5],[10,"new","ncollide_utils::data::owned_allocation_cache","Initializes the cache.",6],[10,"alloc","","Box a value into a potentially already allocated box.",6],[10,"retain","","Retains a box which can be re-used by the `box` method.",6],[10,"clear","","Clears the cache, destroying any stored pointer.",6],[10,"new","ncollide_utils::data::vec_slice","Creates a new immutable slice.",7],[10,"new_unsafe","","Creates a new immutable slice. The size of the data buffer is not checked.",7],[10,"len","","The length of this slice.",7],[10,"is_empty","","Whether or not this slice is empty.",7],[10,"get","","Gets the i-th element of the slice.",7],[10,"get_unchecked","","Gets the i-th element of the slice without bound-checking.",7],[10,"new","","Creates a new mutable slice.",8],[10,"new_unsafe","","Creates a new mutable slice. The size of the data buffer is not checked.",8],[10,"len","","The length of this slice.",8],[10,"is_empty","","Whether or not this slice is empty.",8],[10,"as_slice","","Creates an immutable slice from this mutable slice.",8],[10,"get","","Gets the i-th element of the slice.",8],[10,"get_mut","","Gets a mutable reference to the i-th element of the slice without bound-checking.",8],[10,"get_unchecked","","Gets the i-th element of the slice without bound-checking.",8],[10,"get_unchecked_mut","","Gets a mutable reference to the i-th element of the slice without bound-checking.",8],[10,"copy_from","","Copy the content of another slice.\nBoth slices must have the same length.",8],[10,"new","ncollide_utils::data::ref_with_cost","Creates a new reference packed with a cost value.",9],[10,"eq","","",9],[10,"ne","","",9],[10,"assert_receiver_is_total_eq","","",9],[10,"partial_cmp","","",9],[10,"lt","","",9],[10,"le","","",9],[10,"gt","","",9],[10,"ge","","",9],[10,"cmp","","",9],[10,"decode","ncollide_utils::data::uid_remap","",10],[10,"encode","","",10],[10,"cmp","","",10],[10,"partial_cmp","","",10],[10,"lt","","",10],[10,"le","","",10],[10,"gt","","",10],[10,"ge","","",10],[10,"lt","","",10],[10,"le","","",10],[10,"gt","","",10],[10,"ge","","",10],[10,"assert_receiver_is_total_eq","","",10],[10,"eq","","",10],[10,"ne","","",10],[10,"ne","","",10],[10,"hash","","",10],[10,"clone","","",10],[10,"clone_from","","",10],[10,"fmt","","",10],[10,"new_invalid","","Creates a new invalid key that won't be used by the `UidRemap` structure, ever.",10],[10,"uid","","The small uid contained by this key.",10],[10,"decode","","",11],[10,"encode","","",11],[10,"clone","","",11],[10,"clone_from","","",11],[10,"fmt","","",11],[10,"decode","","",12],[10,"encode","","",12],[10,"clone","","",12],[10,"clone_from","","",12],[10,"fmt","","",12],[10,"default","","",12],[10,"new","","Creates an empty `UidRemap`.",12],[10,"get_fast_key","","Gets the fast key associated to the given key.",12],[10,"len","","Return the number of elements in the map.",12],[10,"is_empty","","Return true if the map contains no elements.",12],[10,"clear","","Clears the map, removing all key-value pairs.",12],[10,"get","","Returns a reference to the value corresponding to the key.",12],[10,"get_fast","","Returns a reference to the value corresponding to the fast key.",12],[10,"contains_key","","Returns true if the map contains a value for the specified key.",12],[10,"contains_fast_key","","Returns true if the map contains a value for the specified fast key.",12],[10,"get_mut","","Returns a mutable reference to the value corresponding to the key.",12],[10,"get_fast_mut","","Returns a mutable reference to the value corresponding to the fast key.",12],[10,"insert","","Inserts a key-value pair to the map. If the key already had a value\npresent in the map, that value and its fast key are returned. Otherwise, `None` is\nreturned.",12],[10,"remove","","Removes a key from the map, returning the value at the key if the key exists.",12],[10,"keys","","Returns an iterator visiting all keys.",12],[10,"values","","Returns an iterator visiting all values.\nThe iterator's element type is `&'r O`.",12],[10,"iter","","Returns an iterator visiting all key-value pairs.",12],[10,"iter_mut","","Returns an iterator visiting all key-value pairs with mutable references to the values.",12],[10,"update","","Updates a value in the map. If the key already exists in the map,\nmodifies the value with `ff` taking `oldval, newval`.\nOtherwise, sets the value to `newval`.\nReturns `true` if the key did not already exist in the map.",12],[10,"update_with_key","","Updates a value in the map. If the key already exists in the map,\nmodifies the value with `ff` taking `key, oldval, newval`.\nOtherwise, sets the value to `newval`.\nReturns `true` if the key did not already exist in the map.",12],[10,"from_iter","","",12],[10,"extend","","",12],[10,"index","","",12],[10,"new","ncollide_utils::optimization","Creates a new backtracking line search methods.",13],[10,"step_size","","",13],[10,"fmt","ncollide_utils::hashable_partial_eq","",14],[10,"rand","","",14],[10,"clone","","",14],[10,"clone_from","","",14],[10,"decode","","",14],[10,"encode","","",14],[10,"eq","","",14],[10,"ne","","",14],[10,"ne","","",14],[10,"new","","Creates a new `HashablePartialEq`. This is unsafe because you must be sure that you really\nwant to transform the wrapped object's partial equality to an equivalence relation.",14],[10,"unwrap","","Gets the wrapped value.",14],[10,"assert_receiver_is_total_eq","","",14],[10,"hash","","",14],[10,"as_bytes","nalgebra::structs::vec","",15],[10,"as_bytes","","",15],[10,"as_bytes","","",16],[10,"as_bytes","","",16],[10,"as_bytes","nalgebra::structs::pnt","",17],[10,"as_bytes","","",17],[10,"as_bytes","","",18],[10,"as_bytes","","",18],[1,"Pair","ncollide::utils::data::pair","An unordered pair of elements implementing `HasUid`."],[11,"first","","first object of the pair",0],[11,"second","","second object of the pair",0],[1,"PairTWHash","","Tomas Wang based hash function for a `Pair` object."],[0,"hash","ncollide::utils::data","Trait for hash functions."],[6,"HashFun","ncollide::utils::data::hash","Hash function."],[9,"hash","","Hash function.",19],[1,"UintPairTWHash","","Hash function for pairs of `usize`, using the Tomas Wang hash."],[1,"UintTWHash","","Hash function for `usize`."],[3,"key_from_pair","","Combines two `usize` on a single one."],[3,"tomas_wang_hash","","Tomas Wang integer hash function."],[0,"hash_map","ncollide::utils::data","An hash map with a customizable hash function."],[1,"Entry","ncollide::utils::data::hash_map","Entry of an `HashMap`."],[11,"key","","The key of the entry.",4],[11,"value","","The value of the entry.",4],[1,"HashMap","","Alternative implementation of `HashMap`."],[0,"owned_allocation_cache","ncollide::utils::data","Allocation cache for owned objects."],[1,"OwnedAllocationCache","ncollide::utils::data::owned_allocation_cache","Cache for owned objects."],[0,"vec_slice","ncollide::utils::data","Slicing on non-contiguous data."],[1,"VecSlice","ncollide::utils::data::vec_slice","A vector slice with a specific length and stride."],[1,"VecSliceMut","","A mutable vector slice with a specific length and stride."],[0,"ref_with_cost","ncollide::utils::data","A reference packed with a cost value."],[1,"RefWithCost","ncollide::utils::data::ref_with_cost","A reference packed with a cost value."],[11,"object","","The reference to an object.",9],[11,"cost","","The cost of the object.",9],[0,"uid_remap","ncollide::utils::data","A map allowing a slow lookup for arbitrary `usize` and fast lookup for small ones."],[1,"FastKey","ncollide::utils::data::uid_remap","A special type of key used by `UidRemap` to perform faster lookups than with the user-defined\nid of type `usize`."],[1,"UidRemap","","A set of values having large usize key."],[3,"center_reduce","ncollide::utils","Centers and reduces a set of data."],[3,"remove_unused_points","","Given an index buffer, remove from `points` every point that is not indexed."],[3,"maximize_with_newton","","Maximizes a real function using the Newton method."],[3,"dsin","","Computes the n-th derivative of the sinus function."],[1,"BacktrackingLineSearch","","The backtracking line search method."],[3,"circumcircle","","Computes the circumcircle of a triangle."],[3,"project_homogeneous_to","","Project n-d point to a (n-1)-d space, dividing each vector by its `w` component."],[3,"binom","","Computes the binomial coefficient C^k_n (\"k among n\")."],[3,"minimize_with_bfgs","","Minimizes a function using the bfgs method."],[3,"is_affinely_dependent_triangle3","","Tests if three 3D points are exactly aligned without the need of the `Cross` trait."],[3,"is_affinely_dependent_triangle","","Tests if three points are exactly aligned."],[6,"LineSearch","","Trait for line search methods."],[9,"step_size","","Gets a near-optimal step size for the next descent.",20],[3,"cov","","Computes the convariance matrix of a set of points."],[6,"AsBytes","","Trait that transforms thing to a slice of u8."],[9,"as_bytes","","",21],[3,"tetrahedron_volume","","Computes the volume of a tetrahedron."],[3,"tetrahedron_signed_volume","","Computes the signed volume of a tetrahedron."],[3,"bfgs","","Minimizes a function using the quasi-newton BFGS method."],[3,"tetrahedron_center","","Computes the center of a tetrahedron."],[3,"is_point_in_triangle","","Tests if a point is inside of a triangle."],[3,"center","","Computes the center of a set of point."],[6,"AnyPrivate","",""],[9,"get_dyn_type_id","","The type id of `Self`.",22],[1,"HashablePartialEq","","A structure that implements `Eq` and is hashable even if the wrapped data implements only\n`PartialEq`."],[3,"cross3","","A 3d cross product that do not require the `Cross<Self, Self>` trait impl."],[3,"newton","","Finds the root of a function using the Newton method."],[3,"project_homogeneous","","Project n-d point to a (n-1)-d space, dividing each vector by its `w` component."],[3,"triangle_perimeter","","Computes the perimeter of a triangle."],[3,"triangle_area","","Computes the area of a triangle."],[3,"cov_and_center","","Computes the covariance matrix and center of a set of points."],[3,"dcos","","Computes the n-th derivative of the cosinus function."],[3,"sort3","","Sorts a set of three values in increasing order."],[0,"shape","ncollide","Collision shapes supported by ncollide."],[10,"decode","ncollide_entities::shape::plane","",23],[10,"encode","","",23],[10,"clone","","",23],[10,"clone_from","","",23],[10,"fmt","","",23],[10,"eq","","",23],[10,"ne","","",23],[10,"ne","","",23],[10,"new","","Builds a new plane from its center and its normal.",23],[10,"new_normalized","","Builds a new plane from its center and its normal.",23],[10,"normal","","The plane normal.",23],[10,"repr","","",23],[10,"decode","ncollide_entities::shape::cuboid","",24],[10,"encode","","",24],[10,"clone","","",24],[10,"clone_from","","",24],[10,"fmt","","",24],[10,"eq","","",24],[10,"ne","","",24],[10,"ne","","",24],[10,"new","","Creates a new box from its half-extents. Half-extents are the box half-width along each\naxis. Each half-extent must be greater than 0.04.",24],[10,"half_extents","","The half-extents of this box. Half-extents are the box half-width along each axis.",24],[10,"fmt","ncollide_entities::shape::minkowski_sum","",25],[10,"new","","Builds the Minkowski sum of two shapes. Since the representation is\nimplicit, this is done in constant time.",25],[10,"m1","","The transformation matrix of the first shape of this Minkowski Sum.",25],[10,"m2","","The transformation matrix of the second shape of this Minkowski Sum.",25],[10,"g1","","The first shape of this Minkowski Sum.",25],[10,"g2","","The second shape of this Minkowski Sum.",25],[10,"fmt","","",26],[10,"new","","Builds the Minkowski sum of two shapes. Since the representation is\nimplicit, this is done in constant time.",26],[10,"m1","","The transformation matrix of the first shape of this Minkowski Sum.",26],[10,"m2","","The transformation matrix of the second shape of this Minkowski Sum.",26],[10,"g1","","The first shape of this Minkowski Sum.",26],[10,"g2","","The second shape of this Minkowski Sum.",26],[10,"decode","ncollide_entities::shape::segment","",27],[10,"encode","","",27],[10,"clone","","",27],[10,"clone_from","","",27],[10,"fmt","","",27],[10,"eq","","",27],[10,"ne","","",27],[10,"ne","","",27],[10,"new","","Creates a new segment from two points.",27],[10,"a","","The first point of this segment.",27],[10,"b","","The second point of this segment.",27],[10,"new_with_vertices_and_indices","","",27],[10,"decode","ncollide_entities::shape::triangle","",28],[10,"encode","","",28],[10,"clone","","",28],[10,"clone_from","","",28],[10,"fmt","","",28],[10,"eq","","",28],[10,"ne","","",28],[10,"ne","","",28],[10,"new","","Creates a triangle from three points.",28],[10,"a","","The fist point of this triangle.",28],[10,"b","","The second point of this triangle.",28],[10,"c","","The third point of this triangle.",28],[10,"new_with_vertices_and_indices","","",28],[10,"clone","ncollide_entities::shape::base_mesh","",29],[10,"clone_from","","",29],[10,"new","","Builds a new mesh.",29],[10,"vertices","","The vertices of this mesh.",29],[10,"bounding_volumes","","Bounding volumes of the subsimplices.",29],[10,"indices","","The indices of this mesh.",29],[10,"uvs","","The texture coordinates of this mesh.",29],[10,"normals","","The normals of this mesh.",29],[10,"bvt","","The acceleration structure used for efficient collision detection and ray casting.",29],[10,"element_at","","Gets the i-th mesh element.",29],[10,"clone","ncollide_entities::shape::trimesh","",30],[10,"clone_from","","",30],[10,"new","","Builds a new mesh.",30],[10,"base_mesh","","The base representation of this mesh.",30],[10,"vertices","","The vertices of this mesh.",30],[10,"bounding_volumes","","Bounding volumes of the subsimplices.",30],[10,"indices","","The indices of this mesh.",30],[10,"uvs","","The texture coordinates of this mesh.",30],[10,"normals","","The normals of this mesh.",30],[10,"bvt","","The acceleration structure used for efficient collision detection and ray casting.",30],[10,"triangle_at","","Gets the i-th mesh element.",30],[10,"clone","ncollide_entities::shape::polyline","",31],[10,"clone_from","","",31],[10,"new","","Builds a new mesh.",31],[10,"base_mesh","","The base representation of this mesh.",31],[10,"vertices","","The vertices of this mesh.",31],[10,"bounding_volumes","","Bounding volumes of the subsimplices.",31],[10,"indices","","The indices of this mesh.",31],[10,"uvs","","The texture coordinates of this mesh.",31],[10,"normals","","The normals of this mesh.",31],[10,"bvt","","The acceleration structure used for efficient collision detection and ray casting.",31],[10,"segment_at","","Gets the i-th mesh element.",31],[10,"decode","ncollide_entities::shape::ball","",32],[10,"encode","","",32],[10,"clone","","",32],[10,"clone_from","","",32],[10,"fmt","","",32],[10,"eq","","",32],[10,"ne","","",32],[10,"ne","","",32],[10,"new","","Creates a new ball from its radius and center.",32],[10,"radius","","The ball radius.",32],[10,"decode","ncollide_entities::shape::capsule","",33],[10,"encode","","",33],[10,"clone","","",33],[10,"clone_from","","",33],[10,"fmt","","",33],[10,"eq","","",33],[10,"ne","","",33],[10,"ne","","",33],[10,"new","","Creates a new capsule.",33],[10,"half_height","","The capsule half length along the `y` axis.",33],[10,"radius","","The radius of the capsule's rounded part.",33],[10,"decode","ncollide_entities::shape::cone","",34],[10,"encode","","",34],[10,"clone","","",34],[10,"clone_from","","",34],[10,"fmt","","",34],[10,"eq","","",34],[10,"ne","","",34],[10,"ne","","",34],[10,"new","","Creates a new cone.",34],[10,"half_height","","The cone half length along the `y` axis.",34],[10,"radius","","The radius of the cone along all but the `y` axis.",34],[10,"decode","ncollide_entities::shape::cylinder","",35],[10,"encode","","",35],[10,"clone","","",35],[10,"clone_from","","",35],[10,"fmt","","",35],[10,"eq","","",35],[10,"ne","","",35],[10,"ne","","",35],[10,"new","","Creates a new cylinder.",35],[10,"half_height","","The cylinder half length along the `y` axis.",35],[10,"radius","","The radius of the cylinder along all but the `y` axis.",35],[10,"fmt","ncollide_entities::shape::reflection","",36],[10,"new","","Build the reflection of a shape. Since the representation is implicit,\nthe reflection computation is done in constant time.",36],[10,"shape","","The reflected shape.",36],[10,"decode","ncollide_entities::shape::torus","",37],[10,"encode","","",37],[10,"clone","","",37],[10,"clone_from","","",37],[10,"fmt","","",37],[10,"eq","","",37],[10,"ne","","",37],[10,"ne","","",37],[10,"new","","Creates a new torus with the given radiuses.",37],[10,"minor_radius","","The torus minor radius.",37],[10,"major_radius","","The torus major radius.",37],[10,"clone","ncollide_entities::shape::compound","",38],[10,"clone_from","","",38],[10,"new","","Builds a new compound shape.",38],[10,"shapes","","The shapes of this compound shape.",38],[10,"bvt","","The optimization structure used by this compound shape.",38],[10,"bounding_volumes","","The shapes bounding volumes.",38],[10,"aabb_at","","The AABB of the i-th shape compositing this compound.",38],[10,"decode","ncollide_entities::shape::convex","",39],[10,"encode","","",39],[10,"clone","","",39],[10,"clone_from","","",39],[10,"fmt","","",39],[10,"eq","","",39],[10,"ne","","",39],[10,"ne","","",39],[10,"new","","Creates a polytope from a set of point.",39],[10,"points","","The list of points of this convex polytope.",39],[10,"map_part_at","ncollide_entities::shape::compound","",38],[10,"map_transformed_part_at","","",38],[10,"aabb_at","","",38],[10,"bvt","","",38],[10,"map_part_at","ncollide_entities::shape::trimesh","",30],[10,"map_transformed_part_at","","",30],[10,"aabb_at","","",30],[10,"bvt","","",30],[10,"map_part_at","ncollide_entities::shape::polyline","",31],[10,"map_transformed_part_at","","",31],[10,"aabb_at","","",31],[10,"bvt","","",31],[10,"support_point","ncollide_entities::shape::cuboid","",24],[10,"sample","","",24],[10,"support_point","ncollide_entities::shape::ball","",32],[10,"sample","","",32],[10,"support_point","ncollide_entities::shape::capsule","",33],[10,"sample","","",33],[10,"support_point","ncollide_entities::shape::cone","",34],[10,"sample","","",34],[10,"support_point","ncollide_entities::shape::cylinder","",35],[10,"sample","","",35],[10,"support_point","ncollide_entities::shape::convex","",39],[10,"sample","","",39],[10,"support_point","ncollide_entities::shape::reflection","",36],[10,"sample","","Applies a function to this shape with a given transform.",36],[10,"support_point","ncollide_entities::shape::triangle","",28],[10,"sample","","",28],[10,"support_point","ncollide_entities::shape::segment","",27],[10,"sample","","",27],[10,"support_point","ncollide_entities::shape::minkowski_sum","",25],[10,"support_point","","",26],[10,"sample","","",25],[10,"sample","","",26],[10,"new","ncollide_entities::bounding_volume::bounding_volume_bvt","Creates a new `BoundingVolumeInterferencesCollector`.",40],[10,"visit_internal","","",40],[10,"visit_leaf","","",40],[10,"decode","ncollide_entities::bounding_volume::aabb","",41],[10,"encode","","",41],[10,"clone","","",41],[10,"clone_from","","",41],[10,"eq","","",41],[10,"ne","","",41],[10,"ne","","",41],[10,"fmt","","",41],[10,"new","","Creates a new AABB.",41],[10,"new_invalid","","Creates an invalid AABB with:\n* `mins = Bounded::max_value()`\n* `maxs = Bounded::max_value()`.\nThis is useful to build aabb using merges.",41],[10,"mins","","Reference to the AABB point with the smallest components along each axis.",41],[10,"maxs","","Reference to the AABB point with the biggest components along each axis.",41],[10,"center","","The center of this AABB.",41],[10,"half_extents","","The half extents of this AABB.",41],[10,"intersects","","",41],[10,"contains","","",41],[10,"merge","","",41],[10,"merged","","",41],[10,"loosen","","",41],[10,"loosened","","",41],[10,"tighten","","",41],[10,"tightened","","",41],[10,"translation","","",41],[10,"inv_translation","","",41],[10,"append_translation","","",41],[10,"append_translation_cpy","","",41],[10,"prepend_translation","","",41],[10,"prepend_translation_cpy","","",41],[10,"set_translation","","",41],[10,"aabb","ncollide_entities::shape::cuboid","",24],[10,"aabb","ncollide_entities::shape::cone","",34],[10,"aabb","ncollide_entities::shape::cylinder","",35],[10,"aabb","ncollide_entities::shape::capsule","",33],[10,"aabb","ncollide_entities::shape::triangle","",28],[10,"aabb","ncollide_entities::shape::segment","",27],[10,"aabb","ncollide_entities::shape::ball","",32],[10,"aabb","ncollide_entities::shape::plane","",23],[10,"aabb","ncollide_entities::shape::convex","",39],[10,"aabb","ncollide_entities::shape::compound","",38],[10,"aabb","ncollide_entities::shape::base_mesh","",29],[10,"aabb","ncollide_entities::shape::trimesh","",30],[10,"aabb","ncollide_entities::shape::polyline","",31],[10,"aabb","ncollide","",42],[10,"decode","ncollide_entities::bounding_volume::bounding_sphere","",43],[10,"encode","","",43],[10,"clone","","",43],[10,"clone_from","","",43],[10,"eq","","",43],[10,"ne","","",43],[10,"ne","","",43],[10,"fmt","","",43],[10,"new","","Creates a new bounding sphere.",43],[10,"center","","The bounding sphere center.",43],[10,"radius","","The bounding sphere radius.",43],[10,"transform_by","","Transforms this bounding sphere by `m`.",43],[10,"intersects","","",43],[10,"contains","","",43],[10,"merge","","",43],[10,"merged","","",43],[10,"loosen","","",43],[10,"loosened","","",43],[10,"tighten","","",43],[10,"tightened","","",43],[10,"translation","","",43],[10,"inv_translation","","",43],[10,"append_translation","","",43],[10,"append_translation_cpy","","",43],[10,"prepend_translation","","",43],[10,"prepend_translation_cpy","","",43],[10,"set_translation","","",43],[10,"bounding_sphere","ncollide_entities::shape::cuboid","",24],[10,"bounding_sphere","ncollide_entities::shape::cone","",34],[10,"bounding_sphere","ncollide_entities::shape::ball","",32],[10,"bounding_sphere","ncollide_entities::shape::cylinder","",35],[10,"bounding_sphere","ncollide_entities::shape::capsule","",33],[10,"bounding_sphere","ncollide_entities::shape::plane","",23],[10,"bounding_sphere","ncollide_entities::shape::convex","",39],[10,"bounding_sphere","ncollide_entities::shape::compound","",38],[10,"bounding_sphere","ncollide_entities::shape::triangle","",28],[10,"bounding_sphere","ncollide_entities::shape::segment","",27],[10,"bounding_sphere","ncollide_entities::shape::base_mesh","",29],[10,"bounding_sphere","ncollide_entities::shape::trimesh","",30],[10,"bounding_sphere","ncollide_entities::shape::polyline","",31],[10,"bounding_sphere","ncollide","",42],[10,"decode","ncollide_entities::partitioning::dbvt","",44],[10,"encode","","",44],[10,"new","","Creates a new Dynamic Bounding Volume Tree.",45],[10,"remove","","Removes a leaf from the tree. Fails if the tree is empty.",45],[10,"insert_new","","Creates, inserts, and returns a new leaf with the given content.",45],[10,"insert","","Inserts a leaf to the tree.",45],[10,"visit","","Visit this tree using… a visitor!",45],[10,"clone","","",46],[10,"clone_from","","",46],[10,"is_root","","Indicates whether this leaf is the root.",46],[10,"is_detached","","Indicates whether this leaf is detached.",46],[10,"clone","","",47],[10,"clone_from","","",47],[10,"new","","Creates a new leaf.",47],[10,"is_root","","Tests if this node is the root.",47],[10,"is_detached","","Tests if this node has no parent.",47],[10,"decode","ncollide_entities::partitioning::bvt","",48],[10,"encode","","",48],[10,"clone","","",48],[10,"clone_from","","",48],[10,"decode","","",49],[10,"encode","","",49],[10,"clone","","",49],[10,"clone_from","","",49],[10,"new_with_partitioner","","Builds a bounding volume tree using an user-defined construction function.",48],[10,"visit","","Visit this tree using… a visitor!",48],[10,"visit_bvtt","","Visits the bounding volume traversal tree implicitely formed with `other`.",48],[10,"best_first_search","","Performs a best-fist-search on the tree.",48],[10,"root_bounding_volume","","Reference to the bounding volume of the tree root.",48],[10,"depth","","Computes the depth of this tree.",48],[10,"new_balanced","","Creates a balanced `BVT`.",48],[10,"bounding_volume","","The bounding volume of this node.",49],[10,"new","ncollide_entities::partitioning::bvt_visitor","Creates a new `BoundingVolumeInterferencesCollector`.",50],[10,"visit_internal","","",50],[10,"visit_leaf","","",50],[10,"new","ncollide_entities::inspection::repr","Creates a new representation descriptor.",51],[10,"type_id","","`TypeId` of this shape's exact type.",51],[10,"repr_id","","`TypeId` of this shape's representation.",51],[10,"repr","","This shape's representation.",51],[10,"downcast_ref","","Converts this repr as an exact shape.",51],[10,"repr","ncollide_entities::shape::compound","",38],[10,"repr","ncollide_entities::shape::trimesh","",30],[10,"repr","ncollide_entities::shape::polyline","",31],[10,"repr","ncollide_entities::shape::ball","",32],[10,"repr","ncollide_entities::shape::capsule","",33],[10,"repr","ncollide_entities::shape::cone","",34],[10,"repr","ncollide_entities::shape::convex","",39],[10,"repr","ncollide_entities::shape::cuboid","",24],[10,"repr","ncollide_entities::shape::cylinder","",35],[10,"repr","ncollide_entities::shape::segment","",27],[10,"repr","ncollide_entities::shape::triangle","",28],[4,"Ball2","ncollide::shape",""],[4,"Plane2","",""],[4,"Cuboid2","",""],[4,"Capsule2","",""],[4,"Cone2","",""],[4,"Cylinder2","",""],[4,"Convex2","",""],[4,"Segment2","",""],[4,"Triangle2","",""],[4,"Polyline2","",""],[4,"Compound2","",""],[4,"Ball3","",""],[4,"Plane3","",""],[4,"Cuboid3","",""],[4,"Capsule3","",""],[4,"Cone3","",""],[4,"Cylinder3","",""],[4,"Convex3","",""],[4,"Segment3","",""],[4,"Triangle3","",""],[4,"Polyline3","",""],[4,"TriMesh3","",""],[4,"Compound3","",""],[1,"TriMesh","","Shape commonly known as a 2d line strip or a 3d triangle mesh."],[1,"Segment","","A segment shape."],[1,"Cylinder","","SupportMap description of a cylinder shape with its principal axis aligned with the `y` axis."],[1,"AnnotatedMinkowskiSum","","Same as the MinkowskiSum but with a support mapping which keeps track of the\noriginal supports points from the two wrapped shapes."],[1,"Torus","","A torus."],[1,"MinkowskiSum","","SupportMap representation of the Minkowski sum of two shapes."],[1,"Ball","","A Ball shape."],[6,"BaseMeshElement","","Trait implemented by elements usable on the Mesh."],[9,"new_with_vertices_and_indices","","Creates a new mesh element from a set of vertices and indices.",52],[1,"Plane","","SupportMap description of a plane."],[1,"Compound","","A compound shape with an aabb bounding volume."],[1,"Convex","","The implicit convex hull of a set of points."],[6,"CompositeShape","","Trait implemented by shapes composed of multiple simpler shapes."],[9,"map_part_at","","Applies a function to each sub-shape of this concave shape.",53],[9,"map_transformed_part_at","","Applies a transformation matrix and a function to each sub-shape of this concave\nshape.",53],[9,"aabb_at","","Gets the AABB of the shape identified by the index `i`.",53],[9,"bvt","","Gets the acceleration structure of the concave shape.",53],[1,"BaseMesh","","A mesh generic wrt. the contained mesh elements characterized by vertices."],[1,"Cone","","SupportMap description of a cylinder shape with its principal axis aligned with the `y` axis."],[1,"Triangle","","A triangle shape."],[1,"Reflection","","SupportMap representation of the reflection of a shape."],[1,"Capsule","","SupportMap description of a capsule shape with its principal axis aligned with the `y` axis."],[1,"Polyline","","Shape commonly known as a 2d line strip or a 3d segment mesh."],[1,"Cuboid","","Shape of a box."],[0,"inspection","ncollide","Traits and methods to inspect and retrieve the capabilities and representations of shapes at runtime."],[4,"Repr2","ncollide::inspection",""],[4,"Repr3","",""],[6,"Repr","","An object with a unique runtime geometric representation."],[9,"repr","","Gets a reference to this object's main representation.",42],[3,"maybe_as_support_map","","Converts a shape to a support map if possible."],[3,"maybe_repr_desc_as_composite_shape","","Converts a shape to a composite shape if possible."],[3,"composite_shape_repr_id","","Gets the id associated with the `CompositeShape` trait."],[3,"maybe_repr_desc_as_support_map","","Converts a shape descriptor to a support map if possible."],[1,"ReprDesc","",""],[3,"maybe_as_composite_shape","","Converts a shape to a composite shape if possible."],[3,"support_map_repr_id","","Gets the id associated with the `SupportMap` trait."],[0,"bounding_volume","ncollide","Bounding volumes."],[4,"BoundingSphere2","ncollide::bounding_volume",""],[4,"AABB2","",""],[4,"BoundingSphere3","",""],[4,"AABB3","",""],[1,"BoundingVolumeInterferencesCollector","","Bounding Volume Tree visitor collecting interferences with a given bounding volume."],[1,"AABB","","An Axis Aligned Bounding Box."],[6,"HasAABB","","Trait of objects that can be bounded by an AABB."],[9,"aabb","","The object’s AABB.",54],[3,"implicit_shape_aabb","","Computes the AABB of an support mapped shape."],[6,"BoundingVolume","","Trait of bounding volumes."],[9,"intersects","","Checks if this bounding volume intersect with another one.",55],[9,"contains","","Checks if this bounding volume contains another one.",55],[9,"merge","","Merges this bounding volume with another one. The merge is done in-place.",55],[9,"merged","","Merges this bounding volume with another one.",55],[9,"loosen","","Enlarges this bounding volume.",55],[9,"loosened","","Creates a new, enlarged version, of this bounding volume.",55],[9,"tighten","","Tighten this bounding volume.",55],[9,"tightened","","Creates a new, tightened version, of this bounding volume.",55],[6,"HasBoundingSphere","","Trait implemented by objects having a bounding sphere."],[9,"bounding_sphere","","The object bounding sphere.",56],[6,"HasBoundingVolume","","Traits of objects having a bounding volume."],[9,"bounding_volume","","The object bounding volume.",57],[3,"point_cloud_aabb","","Computes the AABB of a set of point."],[3,"point_cloud_bounding_sphere_with_center","","Computes the bounding sphere of a set of point, given its center."],[3,"ball_aabb","","Computes the Axis-Aligned Bounding Box of a ball."],[3,"point_cloud_bounding_sphere","","Computes a bounding sphere of the specified set of point."],[1,"BoundingSphere","","A Bounding Sphere."],[0,"partitioning","ncollide","Spatial partitioning tools."],[1,"BVT","ncollide::partitioning","A Boundig Volume Tree."],[3,"median_partitioner_with_centers","","Construction function for a kdree to be used with `BVT::new_with_partitioner`."],[2,"BinaryPartition","","Result of a binary partition."],[12,"Part","","Result of the partitioning of one element.",58],[12,"Parts","","Result of the partitioning of several elements.",58],[1,"BoundingVolumeInterferencesCollector","","Bounding Volume Tree visitor collecting interferences with a given bounding volume."],[2,"BVTNode","","A node of the bounding volume tree."],[12,"Internal","","An internal node.",49],[12,"Leaf","","A leaf.",49],[1,"DBVTLeaf","","Leaf of a Dynamic Bounding Volume Tree."],[11,"bounding_volume","","The bounding volume of this node.",47],[11,"center","","The center of this node bounding volume.",47],[11,"object","","An user-defined object.",47],[6,"BVTCostFn","","Trait implemented by cost functions used by the best-first search on a `BVT`."],[9,"compute_bv_cost","","Computes the cost of a bounding volume.",59],[9,"compute_b_cost","","Computes the cost of an object, and the result to be returned if it is the best one.",59],[1,"DBVT","","A Dynamic Bounding Volume Tree."],[6,"BVTVisitor","","Visitor of Bounding Volume Trees."],[9,"visit_internal","","Visits an internal node. Returns `true` if the internal node children have to be visited\ntoo.",60],[9,"visit_leaf","","Visits a leaf.",60],[6,"BVTTVisitor","","Visitor for the Bounding Volume Traversal Tree."],[9,"visit_internal_internal","","Visit two internal nodes.",61],[9,"visit_leaf_leaf","","Visit two leaves.",61],[9,"visit_internal_leaf","","Visit one internal node and one leaf.",61],[9,"visit_leaf_internal","","Visit one leaf and on internal node.",61],[3,"median_partitioner","","Construction function for a kdree to be used with `BVT::new_with_partitioner`."],[0,"support_map","ncollide","Definition of support functions."],[6,"PreferedSamplingDirections","ncollide::support_map","Trait of shapes having prefered sampling directions for the Minkowski sampling algorithm."],[9,"sample","","Applies a function to this shape with a given transform.",62],[3,"point_cloud_support_point","","Computes the support point of a cloud of points."],[6,"SupportMap","","Traits of convex shapes representable by a support mapping function."],[9,"support_point","","Evaluates the support function of the object. A support function is a\nfunction associating a vector to the shape point which maximizes their\ndot product. This does not include the `margin` of the object. Margins are\nshape-dependent. Use `support_point` to sample the complete shape.",63],[3,"cso_support_point","","Computes the support point of the CSO `g1 - g2` on a given direction."],[0,"geometry","ncollide","Non-persistant pairwise geometric queries."],[0,"algorithms","ncollide::geometry","Algorithms needed for distance and penetration depth computation."],[0,"simplex","ncollide::geometry::algorithms","Abstract definition of a simplex usable by the GJK algorithm."],[6,"Simplex","ncollide::geometry::algorithms::simplex","Trait of a simplex usable by the GJK algorithm."],[9,"reset","","Replace the point of the simplex by a single one. The simplex is reduced to be\n0-dimensional.",64],[9,"add_point","","Adds a point to the simplex.",64],[9,"project_origin_and_reduce","","Project the origin on the simplex and remove any sub-simplex which does not contain the\nprojection.",64],[9,"project_origin","","Projection the origin on the simplex. The simplex itself is unchanged, although it is\nmutable for optimization purpose.",64],[9,"contains_point","","Checks whether a given point is already part of the simplex points.",64],[9,"dimension","","Dimension of the simplex. A simplex with `n` must be a `n - 1`-dimensional simplex.",64],[9,"max_sq_len","","The maximum among the simplex point squared lengths.",64],[9,"modify_pnts","","Modifies the points contained by this simplex.",64],[0,"johnson_simplex","ncollide::geometry::algorithms","Simplex using the Johnson subalgorithm to compute the projection of the origin on the simplex."],[10,"new","ncollide_queries::geometry::algorithms::johnson_simplex","Creates a new, empty, Johnson simplex.",65],[10,"new_w_tls","","Creates a new, empty Johnson simplex. The recursion template uses the thread-local one.",65],[10,"clone","","",65],[10,"clone_from","","",65],[10,"decode","","",66],[10,"encode","","",66],[10,"clone","","",66],[10,"clone_from","","",66],[10,"eq","","",66],[10,"ne","","",66],[10,"ne","","",66],[10,"new","","Creates a new set of Recursion simplex sharable between any Johnson simplex having a\ndimension inferior or equal to `dim`.",66],[10,"reset","","",65],[10,"dimension","","",65],[10,"max_sq_len","","",65],[10,"contains_point","","",65],[10,"add_point","","",65],[10,"project_origin_and_reduce","","",65],[10,"project_origin","","",65],[10,"modify_pnts","","",65],[10,"clone","ncollide_queries::geometry::algorithms::gjk","",67],[10,"clone_from","","",67],[10,"decode","","",67],[10,"encode","","",67],[10,"decode","ncollide_queries::geometry::contacts_internal::contact","",68],[10,"encode","","",68],[10,"clone","","",68],[10,"clone_from","","",68],[10,"eq","","",68],[10,"ne","","",68],[10,"ne","","",68],[10,"fmt","","",68],[10,"new","","Creates a new contact.",68],[10,"flip","","Reverts the contact normal and swaps `world1` and `world2`.",68],[10,"new","ncollide_queries::geometry::distance_internal::composite_shape_against_any","",69],[10,"compute_bv_cost","","",69],[10,"compute_b_cost","","",69],[10,"new","ncollide_queries::geometry::time_of_impact_internal::composite_shape_against_any","",70],[10,"compute_bv_cost","","",70],[10,"compute_b_cost","","",70],[10,"project_point","ncollide::shape","",23],[10,"distance_to_point","","",23],[10,"contains_point","","",23],[10,"project_point_with_transform","","",23],[10,"distance_to_point_with_transform","","",23],[10,"contains_point_with_transform","","",23],[10,"project_point","","",32],[10,"distance_to_point","","",32],[10,"contains_point","","",32],[10,"project_point_with_transform","","",32],[10,"distance_to_point_with_transform","","",32],[10,"contains_point_with_transform","","",32],[10,"project_point","","",24],[10,"distance_to_point","","",24],[10,"contains_point","","",24],[10,"project_point_with_transform","","",24],[10,"distance_to_point_with_transform","","",24],[10,"contains_point_with_transform","","",24],[10,"project_point","ncollide::bounding_volume","",41],[10,"distance_to_point","","",41],[10,"contains_point","","",41],[10,"project_point_with_transform","","",41],[10,"distance_to_point_with_transform","","",41],[10,"contains_point_with_transform","","",41],[10,"project_point","","",43],[10,"distance_to_point","","",43],[10,"contains_point","","",43],[10,"project_point_with_transform","","",43],[10,"distance_to_point_with_transform","","",43],[10,"contains_point_with_transform","","",43],[10,"project_point","ncollide::shape","",35],[10,"distance_to_point","","",35],[10,"contains_point","","",35],[10,"project_point_with_transform","","",35],[10,"distance_to_point_with_transform","","",35],[10,"contains_point_with_transform","","",35],[10,"project_point","","",34],[10,"distance_to_point","","",34],[10,"contains_point","","",34],[10,"project_point_with_transform","","",34],[10,"distance_to_point_with_transform","","",34],[10,"contains_point_with_transform","","",34],[10,"project_point","","",33],[10,"distance_to_point","","",33],[10,"contains_point","","",33],[10,"project_point_with_transform","","",33],[10,"distance_to_point_with_transform","","",33],[10,"contains_point_with_transform","","",33],[10,"project_point","","",39],[10,"distance_to_point","","",39],[10,"contains_point","","",39],[10,"project_point_with_transform","","",39],[10,"distance_to_point_with_transform","","",39],[10,"contains_point_with_transform","","",39],[10,"project_point","","",25],[10,"distance_to_point","","",25],[10,"contains_point","","",25],[10,"project_point_with_transform","","",25],[10,"distance_to_point_with_transform","","",25],[10,"contains_point_with_transform","","",25],[10,"project_point","","",27],[10,"distance_to_point","","",27],[10,"contains_point","","",27],[10,"project_point_with_transform","","",27],[10,"distance_to_point_with_transform","","",27],[10,"contains_point_with_transform","","",27],[10,"project_point","","",28],[10,"distance_to_point","","",28],[10,"contains_point","","",28],[10,"project_point_with_transform","","",28],[10,"distance_to_point_with_transform","","",28],[10,"contains_point_with_transform","","",28],[10,"project_point","","",38],[10,"distance_to_point","","",38],[10,"contains_point","","",38],[10,"project_point_with_transform","","",38],[10,"distance_to_point_with_transform","","",38],[10,"contains_point_with_transform","","",38],[10,"compute_bv_cost","ncollide_queries::point::point_compound","",71],[10,"compute_b_cost","","",71],[10,"visit_internal","","",72],[10,"visit_leaf","","",72],[10,"project_point","ncollide::shape","",29],[10,"distance_to_point","","",29],[10,"contains_point","","",29],[10,"project_point_with_transform","","",29],[10,"distance_to_point_with_transform","","",29],[10,"contains_point_with_transform","","",29],[10,"compute_bv_cost","ncollide_queries::point::point_mesh","",73],[10,"compute_b_cost","","",73],[10,"visit_internal","","",74],[10,"visit_leaf","","",74],[10,"project_point","ncollide::shape","",30],[10,"distance_to_point","","",30],[10,"contains_point","","",30],[10,"project_point_with_transform","","",30],[10,"distance_to_point_with_transform","","",30],[10,"contains_point_with_transform","","",30],[10,"project_point","","",31],[10,"distance_to_point","","",31],[10,"contains_point","","",31],[10,"project_point_with_transform","","",31],[10,"distance_to_point_with_transform","","",31],[10,"contains_point_with_transform","","",31],[10,"project_point","ncollide::geometry::algorithms","",42],[10,"distance_to_point","","",42],[10,"contains_point","","",42],[10,"project_point_with_transform","","",42],[10,"distance_to_point_with_transform","","",42],[10,"contains_point_with_transform","","",42],[10,"new","ncollide_queries::point::point_bvt","Creates a new `PointInterferencesCollector`.",75],[10,"visit_internal","","",75],[10,"visit_leaf","","",75],[10,"clone","ncollide_queries::ray::ray","",76],[10,"clone_from","","",76],[10,"decode","","",76],[10,"encode","","",76],[10,"fmt","","",76],[10,"new","","Creates a new ray starting from `orig` and with the direction `dir`. `dir` must be\nnormalized.",76],[10,"new_with_uvs","","Creates a new `RayIntersection`.",77],[10,"new","","Creates a new `RayIntersection`.",77],[10,"toi_and_normal_with_ray","ncollide::shape","",23],[10,"toi_with_ray","","",23],[10,"toi_and_normal_and_uv_with_ray","","",23],[10,"intersects_ray","","",23],[10,"toi_with_transform_and_ray","","",23],[10,"toi_and_normal_with_transform_and_ray","","",23],[10,"toi_and_normal_and_uv_with_transform_and_ray","","",23],[10,"intersects_with_transform_and_ray","","",23],[10,"toi_with_ray","","",32],[10,"toi_and_normal_with_ray","","",32],[10,"toi_and_normal_and_uv_with_ray","","",32],[10,"toi_with_ray","","",32],[10,"toi_and_normal_and_uv_with_ray","","",32],[10,"intersects_ray","","",32],[10,"toi_with_transform_and_ray","","",32],[10,"toi_with_transform_and_ray","","",32],[10,"toi_and_normal_with_transform_and_ray","","",32],[10,"toi_and_normal_and_uv_with_transform_and_ray","","",32],[10,"intersects_with_transform_and_ray","","",32],[10,"toi_with_ray","","",24],[10,"toi_and_normal_with_ray","","",24],[10,"toi_and_normal_and_uv_with_ray","","",24],[10,"toi_with_ray","","",24],[10,"toi_and_normal_and_uv_with_ray","","",24],[10,"intersects_ray","","",24],[10,"toi_with_transform_and_ray","","",24],[10,"toi_and_normal_with_transform_and_ray","","",24],[10,"toi_and_normal_and_uv_with_transform_and_ray","","",24],[10,"intersects_with_transform_and_ray","","",24],[10,"toi_with_ray","ncollide::bounding_volume","",41],[10,"toi_and_normal_with_ray","","",41],[10,"toi_and_normal_and_uv_with_ray","","",41],[10,"toi_with_ray","","",41],[10,"toi_and_normal_and_uv_with_ray","","",41],[10,"intersects_ray","","",41],[10,"toi_with_transform_and_ray","","",41],[10,"toi_and_normal_with_transform_and_ray","","",41],[10,"toi_and_normal_and_uv_with_transform_and_ray","","",41],[10,"intersects_with_transform_and_ray","","",41],[10,"toi_with_ray","","",43],[10,"toi_and_normal_with_ray","","",43],[10,"toi_and_normal_and_uv_with_ray","","",43],[10,"intersects_ray","","",43],[10,"toi_with_ray","","",43],[10,"toi_and_normal_and_uv_with_ray","","",43],[10,"intersects_ray","","",43],[10,"toi_with_transform_and_ray","","",43],[10,"toi_and_normal_with_transform_and_ray","","",43],[10,"toi_and_normal_and_uv_with_transform_and_ray","","",43],[10,"intersects_with_transform_and_ray","","",43],[10,"toi_and_normal_with_ray","ncollide::shape","",35],[10,"toi_with_ray","","",35],[10,"toi_and_normal_and_uv_with_ray","","",35],[10,"intersects_ray","","",35],[10,"toi_with_transform_and_ray","","",35],[10,"toi_and_normal_with_transform_and_ray","","",35],[10,"toi_and_normal_and_uv_with_transform_and_ray","","",35],[10,"intersects_with_transform_and_ray","","",35],[10,"toi_and_normal_with_ray","","",34],[10,"toi_with_ray","","",34],[10,"toi_and_normal_and_uv_with_ray","","",34],[10,"intersects_ray","","",34],[10,"toi_with_transform_and_ray","","",34],[10,"toi_and_normal_with_transform_and_ray","","",34],[10,"toi_and_normal_and_uv_with_transform_and_ray","","",34],[10,"intersects_with_transform_and_ray","","",34],[10,"toi_and_normal_with_ray","","",33],[10,"toi_with_ray","","",33],[10,"toi_and_normal_and_uv_with_ray","","",33],[10,"intersects_ray","","",33],[10,"toi_with_transform_and_ray","","",33],[10,"toi_and_normal_with_transform_and_ray","","",33],[10,"toi_and_normal_and_uv_with_transform_and_ray","","",33],[10,"intersects_with_transform_and_ray","","",33],[10,"toi_and_normal_with_ray","","",39],[10,"toi_with_ray","","",39],[10,"toi_and_normal_and_uv_with_ray","","",39],[10,"intersects_ray","","",39],[10,"toi_with_transform_and_ray","","",39],[10,"toi_and_normal_with_transform_and_ray","","",39],[10,"toi_and_normal_and_uv_with_transform_and_ray","","",39],[10,"intersects_with_transform_and_ray","","",39],[10,"toi_and_normal_with_ray","","",27],[10,"toi_with_ray","","",27],[10,"toi_and_normal_and_uv_with_ray","","",27],[10,"intersects_ray","","",27],[10,"toi_with_transform_and_ray","","",27],[10,"toi_and_normal_with_transform_and_ray","","",27],[10,"toi_and_normal_and_uv_with_transform_and_ray","","",27],[10,"intersects_with_transform_and_ray","","",27],[10,"toi_and_normal_with_ray","","",25],[10,"toi_with_ray","","",25],[10,"toi_and_normal_and_uv_with_ray","","",25],[10,"intersects_ray","","",25],[10,"toi_with_transform_and_ray","","",25],[10,"toi_and_normal_with_transform_and_ray","","",25],[10,"toi_and_normal_and_uv_with_transform_and_ray","","",25],[10,"intersects_with_transform_and_ray","","",25],[10,"toi_and_normal_with_ray","","",28],[10,"toi_with_ray","","",28],[10,"toi_and_normal_and_uv_with_ray","","",28],[10,"intersects_ray","","",28],[10,"toi_with_transform_and_ray","","",28],[10,"toi_and_normal_with_transform_and_ray","","",28],[10,"toi_and_normal_and_uv_with_transform_and_ray","","",28],[10,"intersects_with_transform_and_ray","","",28],[10,"toi_with_ray","","",38],[10,"toi_and_normal_with_ray","","",38],[10,"toi_with_ray","","",38],[10,"toi_and_normal_and_uv_with_ray","","",38],[10,"intersects_ray","","",38],[10,"toi_with_transform_and_ray","","",38],[10,"toi_and_normal_with_transform_and_ray","","",38],[10,"toi_and_normal_and_uv_with_transform_and_ray","","",38],[10,"intersects_with_transform_and_ray","","",38],[10,"compute_bv_cost","ncollide_queries::ray::ray_compound","",78],[10,"compute_b_cost","","",78],[10,"compute_bv_cost","","",79],[10,"compute_b_cost","","",79],[10,"toi_with_ray","ncollide::shape","",29],[10,"toi_and_normal_with_ray","","",29],[10,"toi_and_normal_and_uv_with_ray","","",29],[10,"toi_with_ray","","",29],[10,"toi_and_normal_and_uv_with_ray","","",29],[10,"intersects_ray","","",29],[10,"toi_with_transform_and_ray","","",29],[10,"toi_and_normal_with_transform_and_ray","","",29],[10,"toi_and_normal_and_uv_with_transform_and_ray","","",29],[10,"intersects_with_transform_and_ray","","",29],[10,"compute_bv_cost","ncollide_queries::ray::ray_mesh","",80],[10,"compute_b_cost","","",80],[10,"compute_bv_cost","","",81],[10,"compute_b_cost","","",81],[10,"compute_bv_cost","","",82],[10,"compute_b_cost","","",82],[10,"toi_with_ray","ncollide::shape","",30],[10,"toi_and_normal_with_ray","","",30],[10,"toi_and_normal_and_uv_with_ray","","",30],[10,"toi_with_ray","","",30],[10,"toi_and_normal_and_uv_with_ray","","",30],[10,"intersects_ray","","",30],[10,"toi_with_transform_and_ray","","",30],[10,"toi_and_normal_with_transform_and_ray","","",30],[10,"toi_and_normal_and_uv_with_transform_and_ray","","",30],[10,"intersects_with_transform_and_ray","","",30],[10,"toi_with_ray","","",31],[10,"toi_and_normal_with_ray","","",31],[10,"toi_and_normal_and_uv_with_ray","","",31],[10,"toi_with_ray","","",31],[10,"toi_and_normal_and_uv_with_ray","","",31],[10,"intersects_ray","","",31],[10,"toi_with_transform_and_ray","","",31],[10,"toi_and_normal_with_transform_and_ray","","",31],[10,"toi_and_normal_and_uv_with_transform_and_ray","","",31],[10,"intersects_with_transform_and_ray","","",31],[10,"toi_with_ray","ncollide::geometry::algorithms","",42],[10,"toi_and_normal_with_ray","","",42],[10,"toi_and_normal_and_uv_with_ray","","",42],[10,"intersects_ray","","",42],[10,"toi_with_ray","","",42],[10,"toi_and_normal_and_uv_with_ray","","",42],[10,"intersects_ray","","",42],[10,"toi_with_transform_and_ray","","",42],[10,"toi_and_normal_with_transform_and_ray","","",42],[10,"toi_and_normal_and_uv_with_transform_and_ray","","",42],[10,"intersects_with_transform_and_ray","","",42],[10,"new","ncollide_queries::ray::ray_bvt","Creates a new `BestRayInterferenceSearch`.",83],[10,"compute_bv_cost","","",83],[10,"compute_b_cost","","",83],[10,"new","","Creates a new `RayInterferencesCollector`.",84],[10,"visit_internal","","",84],[10,"visit_leaf","","",84],[1,"JohnsonSimplex","ncollide::geometry::algorithms::johnson_simplex","Simplex using the Johnson subalgorithm to compute the projection of the origin on the simplex."],[1,"RecursionTemplate","","Set of indices to explain to the JohnsonSimplex how to do its work.\nBuilding this is very time consuming, and thus should be shared between all instances of the\nJohnson simplex."],[0,"gjk","ncollide::geometry::algorithms","The Gilbert–Johnson–Keerthi distance algorithm."],[2,"GJKResult","ncollide::geometry::algorithms::gjk","Results of the GJK algorithm."],[12,"Intersection","","Result of the GJK algorithm when the origin is inside of the polytope.",67],[12,"Projection","","Result of the GJK algorithm when a projection of the origin on the polytope is found.",67],[12,"NoIntersection","","Result of the GJK algorithm when the origin is to far away from the polytope.",67],[3,"closest_points","","Computes the closest points between two convex shapes unsing the GJK\nalgorithm."],[3,"closest_points_with_max_dist","","Computes the closest points between two convex shapes unsing the GJK algorithm."],[3,"distance","","Computes the exact distance separating two convex shapes unsing the GJK.\nalgorithm."],[3,"project_origin","","Projects the origin on a shape unsing the GJK algorithm."],[3,"project_origin_with_max_dist","","Projects the origin on a shape using the Separating Axis GJK algorithm.\nThe algorithm will stop as soon as the polytope can be proven to be at least `max_dist` away\nfrom the origin."],[3,"cast_ray","","Casts a ray on a support map using the GJK algorithm."],[0,"minkowski_sampling","ncollide::geometry::algorithms","Penetration depth computation algorithm approximating the Minkowskis sum."],[3,"closest_points","ncollide::geometry::algorithms::minkowski_sampling","Computes the closest points between two implicit inter-penetrating shapes. Returns None if the\nshapes are not in penetration. This can be used as a fallback algorithm for the GJK algorithm."],[3,"project_origin","","Projects the origin on a support-mapped shape."],[0,"contacts_internal","ncollide::geometry","Implementation details of the `contact` and `contacts` functions."],[3,"any_against_composite_shape","ncollide::geometry::contacts_internal","Best contact between a shape and a composite (`Mesh`, `Compound`) shape."],[3,"any_against_any","","Computes the minimum distance separating two shapes."],[3,"plane_against_support_map","","Contact between a plane and a support-mapped shape (Cuboid, Convex, etc.)"],[3,"support_map_against_support_map_with_params","","Contact between support-mapped shapes (`Cuboid`, `Convex`, etc.)"],[3,"support_map_against_plane","","Contact between a support-mapped shape (Cuboid, Convex, etc.) and a plane."],[3,"any_against_any","","Computes the minimum distance separating two shapes."],[3,"composite_shape_against_any","","Best contact between a composite shape (`Mesh`, `Compound`) and any other shape."],[1,"Contact","","Geometric description of a contact."],[11,"world1","","Position of the contact on the first object. The position is expressed in world space.",68],[11,"world2","","Position of the contact on the second object. The position is expressed in world space.",68],[11,"normal","","Contact normal",68],[11,"depth","","Penetration depth",68],[3,"support_map_against_support_map","","Contact between support-mapped shapes (`Cuboid`, `Convex`, etc.)"],[3,"ball_against_ball","","Contact between balls."],[0,"distance_internal","ncollide::geometry","Implementation details of the `distance` function."],[3,"composite_shape_against_any","ncollide::geometry::distance_internal","Smallest distance between a composite shape and any other shape."],[3,"any_against_composite_shape","","Smallest distance between a shape and a composite shape."],[3,"support_map_against_support_map","","Distance between support-mapped shapes."],[3,"any_against_any","","Computes the minimum distance separating two shapes."],[3,"plane_against_support_map","","Distance between a plane and a support-mapped shape."],[3,"ball_against_ball","","Distance between balls."],[3,"support_map_against_plane","","Distance between a support-mapped shape and a plane."],[3,"any_against_any","","Computes the minimum distance separating two shapes."],[3,"support_map_against_support_map_with_params","","Distance between support-mapped shapes."],[0,"time_of_impact_internal","ncollide::geometry","Implementation details of the `distance` function."],[3,"any_against_any","ncollide::geometry::time_of_impact_internal","Computes the minimum distance separating two shapes."],[3,"ball_against_ball","","Time Of Impact of two balls under translational movement."],[3,"plane_against_support_map","","Time Of Impact of a plane with a support-mapped shape under translational movement."],[3,"support_map_against_plane","","Time Of Impact of a plane with a support-mapped shape under translational movement."],[3,"support_map_against_support_map","","Time of impacts between two support-mapped shapes under translational movement."],[3,"any_against_any","","Computes the minimum distance separating two shapes."],[3,"any_against_composite_shape","","Time Of Impact of any shape with a composite shape, under translational movement."],[3,"composite_shape_against_any","","Time Of Impact of a composite shape with any other shape, under translational movement."],[1,"Contact","ncollide::geometry","Geometric description of a contact."],[11,"world1","","Position of the contact on the first object. The position is expressed in world space.",68],[11,"world2","","Position of the contact on the second object. The position is expressed in world space.",68],[11,"normal","","Contact normal",68],[11,"depth","","Penetration depth",68],[3,"any_against_any","","Computes the minimum distance separating two shapes."],[3,"any_against_any","","Computes the minimum distance separating two shapes."],[3,"any_against_any","","Computes the minimum distance separating two shapes."],[0,"point","ncollide","Point inclusion and projection."],[6,"LocalPointQuery","ncollide::point","Trait of objects that can be tested for point inclusion and projection."],[9,"project_point","","Projects a point on `self`.",85],[9,"distance_to_point","","Computes the minimal distance between a point and `self`.",85],[9,"contains_point","","Tests if the given point is inside of `self`.",85],[1,"PointInterferencesCollector","","Bounding Volume Tree visitor collecting nodes that may contain a given point."],[6,"PointQuery","","Trait of objects that can be transformed and tested for point inclusion and projection."],[9,"project_point_with_transform","","Projects a point on `self` transformed by `m`.",86],[9,"distance_to_point_with_transform","","Computes the minimal distance between a point and `self` transformed by `m`.",86],[9,"contains_point_with_transform","","Tests if the given point is inside of `self` transformed by `m`.",86],[0,"ray","ncollide","Ray-casting related definitions and implementations."],[4,"Ray3","ncollide::ray",""],[4,"Ray2","",""],[4,"RayIntersection3","",""],[4,"RayIntersection2","",""],[1,"Ray","","A Ray."],[11,"orig","","Starting point of the ray.",76],[11,"dir","","Direction of the ray.",76],[1,"RayIntersectionCostFn","","A search thet selects the objects that has the smallest time of impact with a given ray."],[1,"RayIntersection","","Structure containing the result of a successful ray cast."],[11,"toi","","The time of impact of the ray with the object.  The exact contact point can be computed\nwith: `orig + dir * toi` where `orig` is the origin of the ray; `dir` is its direction and\n`toi` is the value of this field.",77],[11,"normal","","The normal at the intersection point.",77],[11,"uvs","","The textures coordinates at the intersection point.  This is an `Option` because some shape\ndo not support texture coordinates.",77],[3,"triangle_ray_intersection","","Computes the intersection between a triangle and a ray."],[3,"plane_toi_with_ray","","Computes the toi of a ray with a plane described by its center and normal."],[1,"RayInterferencesCollector","","Bounding Volume Tree visitor collecting interferences with a given ray."],[6,"RayCast","","Traits of objects which can be transformed and tested for intersection with a ray."],[9,"toi_with_transform_and_ray","","Computes the time of impact between this transform shape and a ray.",87],[9,"toi_and_normal_with_transform_and_ray","","Computes the time of impact, and normal between this transformed shape and a ray.",87],[9,"toi_and_normal_and_uv_with_transform_and_ray","","Computes time of impact, normal, and texture coordinates (uv) between this transformed\nshape and a ray.",87],[9,"intersects_with_transform_and_ray","","Tests whether a ray intersects this transformed shape.",87],[6,"LocalRayCast","","Traits of objects which can be tested for intersection with a ray."],[9,"toi_with_ray","","Computes the time of impact between this shape and a ray",88],[9,"toi_and_normal_with_ray","","Computes the intersection point between this shape and a ray.",88],[9,"toi_and_normal_and_uv_with_ray","","Computes the intersection point and normal between this shape and a ray.",88],[9,"intersects_ray","","Tests whether a ray intersects this shape.",88],[3,"implicit_toi_and_normal_with_ray","","Cast a ray on a shape using the GJK algorithm."],[3,"ball_toi_with_ray","","Computes the time of impact of a ray on a ball."],[0,"narrow_phase","ncollide","Collision detection algorithms and structure for the Narrow Phase."],[1,"BasicCollisionDispatcher","ncollide::narrow_phase","Collision dispatcher for shapes defined by `ncollide_entities`."],[1,"CompositeShapeRepr","","Collision detector between a concave shape and another shape."],[4,"CollisionAlgorithm","",""],[1,"SupportMapSupportMap","","Persistent collision detector between two shapes having a support mapping function."],[1,"PlaneSupportMap","","Collision detector between a plane and a shape implementing the `SupportMap` trait."],[6,"CollisionDetector","","Trait of the algorithms executed during the so-called Narrow Phase."],[9,"update","","Runs the collision detection on two objects. It is assumed that the same\ncollision detector (the same structure) is always used with the same\npair of object.",89],[9,"num_colls","","The number of collision detected during the last update.",89],[9,"colls","","Collects the collisions detected during the last update.",89],[1,"ReprCompositeShape","","Collision detector between a shape and a concave shape."],[1,"ContactSignal","","Signal for contact start/stop."],[6,"ContactSignalHandler","","A signal handler for contact detection."],[9,"handle_contact","","Activate an action for when two objects start or stop to be close to each other.",90],[1,"IncrementalContactManifoldGenerator","","Contact manifold generator which keeps track of several contacts."],[1,"BallBall","","Collision detector between two balls."],[6,"CollisionDispatcher","",""],[9,"get_collision_algorithm","","Allocate a collision algorithm corresponding to the given pair of shapes.",91],[1,"OneShotContactManifoldGenerator","","Contact manifold generator producing a full manifold at the first update."],[1,"SupportMapPlane","","Collision detector between a plane and a shape implementing the `SupportMap` trait."],[0,"broad_phase","ncollide","Broad phases."],[6,"BroadPhase","ncollide::broad_phase","Trait all broad phase must implement."],[9,"defered_add","","Tells the broad phase to add an element during the next update.",92],[9,"defered_remove","","Tells the broad phase to remove an element during the next update.",92],[9,"defered_set_bounding_volume","","Sets the next bounding volume to be used during the update of this broad phase.",92],[9,"update","","Updates the object additions, removals, and interferences detection.",92],[9,"interferences_with_bounding_volume","","Collects every object which might intersect a given bounding volume.",92],[9,"interferences_with_ray","","Collects every object which might intersect a given ray.",92],[9,"interferences_with_point","","Collects every object which might contain a given point.",92],[1,"DBVTBroadPhase","","Broad phase based on a Dynamic Bounding Volume Tree."],[0,"world","ncollide","High level API to detect collisions in large, complex scenes."],[4,"BroadPhaseObject","ncollide::world",""],[1,"CollisionObjectsDispatcher","","Collision detector dispatcher for collision objects."],[1,"CollisionWorld","","A world that handles collision objects."],[1,"CollisionObject","","A stand-alone object that has a position and a shape."],[11,"position","","The position of the collision object.",93],[11,"shape","","The shape of the collision object.",93],[11,"collision_groups","","The collision groups of the collision object.",93],[11,"data","","The data associated to this object.",93],[1,"CollisionGroups","","30 groups of collision used to filter which object collide with which other one."],[0,"procedural","ncollide",""],[0,"utils","ncollide::procedural","Utilities useful for various generations tasks."],[3,"push_circle","ncollide::procedural::utils","Pushes a discretized counterclockwise circle to a buffer."],[3,"push_xy_arc","","Pushes a discretized counterclockwise circle to a buffer.\nThe circle is contained on the plane spanned by the `x` and `y` axis."],[3,"push_ring_indices","","Creates the faces from two circles with the same discretization."],[3,"push_open_ring_indices","","Creates the faces from two circles with the same discretization."],[3,"push_degenerate_top_ring_indices","","Creates the faces from a circle and a point that is shared by all triangle."],[3,"push_degenerate_open_top_ring_indices","","Creates the faces from a circle and a point that is shared by all triangle."],[3,"push_filled_circle_indices","","Pushes indices so that a circle is filled with triangles. Each triangle will have the\n`base_circle` point in common.\nPushes `nsubdiv - 2` elements to `out`."],[3,"push_rectangle_indices","","Given four corner points, pushes to two counterclockwise triangles to `out`."],[3,"reverse_clockwising","","Reverses the clockwising of a set of faces."],[3,"split_index_buffer","","Duplicates the indices of each triangle on the given index buffer."],[3,"split_index_buffer_and_recover_topology","","Duplicates the indices of each triangle on the given index buffer, giving the same id to each\nidentical vertex."],[3,"compute_normals","","Computes the normals of a set of vertices."],[0,"path","ncollide::procedural","Path generation."],[10,"new","ncollide_procedural::path::polyline_path","Creates a new polyline-based path.",94],[10,"new","ncollide_procedural::path::no_cap","Creates a new `NoCap`.",95],[10,"gen_start_cap","","",95],[10,"gen_end_cap","","",95],[10,"new","ncollide_procedural::path::arrowhead_cap","Creates a cap that looks like an arrow.",96],[10,"gen_end_cap","","",96],[10,"gen_start_cap","","",96],[10,"new","ncollide_procedural::path::polyline_pattern","Creates a new polyline pattern.",97],[10,"stroke","","",97],[10,"next","ncollide_procedural::path::polyline_path","",94],[10,"fmt","ncollide_procedural::trimesh","",98],[10,"clone","","",98],[10,"clone_from","","",98],[10,"unwrap_unified","","Returns the unified index buffer data or fails.",98],[10,"unwrap_split","","Returns the split index buffer data or fails.",98],[10,"fmt","","",99],[10,"clone","","",99],[10,"clone_from","","",99],[10,"new","","Creates a new `TriMesh`.",99],[10,"has_normals","","Whether or not this triangle mesh has normals.",99],[10,"has_uvs","","Whether or not this triangle mesh has texture coordinates.",99],[10,"translate_by","","Translates each vertex of this mesh.",99],[10,"transform_by","","Transforms each vertex and rotates each normal of this mesh.",99],[10,"num_triangles","","The number of triangles on this mesh.",99],[10,"rotate_by","","Rotates each vertex and normal of this mesh.",99],[10,"recompute_normals","","Recomputes the mesh normals using its vertex coordinates and adjascency informations\ninfered from the index buffer.",99],[10,"scale_by","","Scales each vertex of this mesh.",99],[10,"scale_by_scalar","","Scales each vertex of this mesh.",99],[10,"unify_index_buffer","","Force the mesh to use the same index for vertices, normals and uvs.",99],[10,"split_index_buffer","","Forces the mesh to use a different index for the vertices, normals and uvs.",99],[10,"clone","ncollide_procedural::polyline","",100],[10,"clone_from","","",100],[10,"new","","Creates a new polyline.",100],[10,"translate_by","","Translates each vertex of this polyline.",100],[10,"rotate_by","","Rotates each vertex and normal of this polyline.",100],[10,"transform_by","","Transforms each vertex and rotates each normal of this polyline.",100],[10,"scale_by_scalar","","Scales each vertex of this polyline.",100],[10,"scale_by","","Scales each vertex of this mesh.",100],[1,"PolylinePath","ncollide::procedural::path","A path with its sample points given by a polyline."],[6,"PolylineCompatibleCap","","Trait to be implemented by caps compatible with a `PolylinePattern`."],[9,"gen_start_cap","","Generates the mesh for the cap at the beginning of a path.",101],[9,"gen_end_cap","","Generates the mesh for the cap at the end of a path.",101],[1,"ArrowheadCap","","A cap that looks like an arrow."],[2,"PathSample","","A sample point and its associated tangent."],[12,"StartPoint","","A point that starts a new path.",102],[12,"InnerPoint","","A point that is inside of the path currently generated.",102],[12,"EndPoint","","A point that ends the path currently generated.",102],[12,"EndOfSample","","Used when the sampler does not have any other points to generate.",102],[1,"PolylinePattern","","A pattern composed of polyline and two caps."],[1,"NoCap","","A cap that renders nothing."],[6,"CurveSampler","","A curve sampler."],[9,"next","","Returns the next sample point.",103],[6,"StrokePattern","","A pattern that is replicated along a path."],[9,"stroke","","Generates the mesh using this pattern and the curve sampled by `sampler`.",104],[4,"TriMesh3","ncollide::procedural",""],[4,"Polyline3","",""],[4,"TriMesh2","",""],[4,"Polyline2","",""],[3,"cuboid","","Generates a cuboid shape with a split index buffer."],[1,"TriMesh","","Shapeetric description of a mesh."],[11,"coords","","Coordinates of the mesh vertices.",99],[11,"normals","","Coordinates of the mesh normals.",99],[11,"uvs","","Textures coordinates of the mesh.",99],[11,"indices","","Index buffer of the mesh.",99],[3,"unit_circle","","Creates a circle lying on the `(x,y)` plane."],[3,"rectangle","","The contour of a cuboid lying on the x-y plane."],[3,"unit_cylinder","","Generates a cylinder with unit height and diameter."],[3,"cone","","Generates a cone with a given height and diameter."],[3,"unit_cuboid","","Generates a cuboid shape with a split index buffer."],[3,"circle","","Creates a circle lying on the `(x,y)` plane."],[3,"capsule","","Generates a capsule."],[3,"unit_sphere","","Generates a UV sphere centered at the origin and with a unit diameter."],[3,"unit_cone","","Generates a cone with unit height and diameter."],[3,"quad_with_vertices","","Adds a double-sided quad with the specified grid of vertices."],[3,"quad","","Adds a double-sided quad to the scene."],[3,"sphere","","Generates a UV sphere."],[3,"unit_rectangle","","The contour of a unit cuboid lying on the x-y plane."],[3,"unit_hemisphere","","Creates an hemisphere with a diameter of 1."],[1,"Polyline","","Shapeetric description of a polyline."],[11,"coords","","Coordinates of the polyline vertices.",100],[11,"normals","","Coordinates of the polyline normals.",100],[2,"IndexBuffer","","Different representations of the index buffer."],[12,"Unified","","The vertex, normal, and uvs share the same indices.",98],[12,"Split","","The vertex, normal, and uvs have different indices.",98],[3,"bezier_curve","","Given a set of control points, generates a (non-rational) Bezier curve."],[3,"bezier_surface","","Given a set of control points, generates a (non-rational) Bezier surface."],[3,"unit_quad","","Adds a double-sided quad with unit size to the scene."],[3,"cylinder","","Generates a cylinder with a given height and diameter."],[0,"transformation","ncollide",""],[6,"ToTriMesh","ncollide::transformation","Trait implemented by shapes that can be approximated by a triangle mesh."],[9,"to_trimesh","","Builds a triangle mesh from this shape.",105],[3,"triangulate","","Triangulates a set of point (sort of) lying on the same 2d plane."],[3,"convex_hull2_idx","","Computes the convex hull of a set of 2d points and returns only the indices of the hull\nvertices."],[3,"convex_hull2","","Computes the convex hull of a set of 2d points."],[3,"convex_hull3","","Computes the convex hull of a set of 3d points."],[3,"hacd","","Approximate convex decomposition of a triangle mesh."],[6,"ToPolyline","","Trait implemented by shapes that can be approximated by a triangle mesh."],[9,"to_polyline","","Builds a triangle mesh from this shape.",106]],"paths":[[1,"Pair"],[1,"PairTWHash"],[1,"UintPairTWHash"],[1,"UintTWHash"],[1,"Entry"],[1,"HashMap"],[1,"OwnedAllocationCache"],[1,"VecSlice"],[1,"VecSliceMut"],[1,"RefWithCost"],[1,"FastKey"],[1,"LookupData"],[1,"UidRemap"],[1,"BacktrackingLineSearch"],[1,"HashablePartialEq"],[1,"Vec3"],[1,"Vec2"],[1,"Pnt3"],[1,"Pnt2"],[6,"HashFun"],[6,"LineSearch"],[6,"AsBytes"],[6,"AnyPrivate"],[1,"Plane"],[1,"Cuboid"],[1,"MinkowskiSum"],[1,"AnnotatedMinkowskiSum"],[1,"Segment"],[1,"Triangle"],[1,"BaseMesh"],[1,"TriMesh"],[1,"Polyline"],[1,"Ball"],[1,"Capsule"],[1,"Cone"],[1,"Cylinder"],[1,"Reflection"],[1,"Torus"],[1,"Compound"],[1,"Convex"],[1,"BoundingVolumeInterferencesCollector"],[1,"AABB"],[6,"Repr"],[1,"BoundingSphere"],[2,"UpdateState"],[1,"DBVT"],[2,"DBVTLeafState"],[1,"DBVTLeaf"],[1,"BVT"],[2,"BVTNode"],[1,"BoundingVolumeInterferencesCollector"],[1,"ReprDesc"],[6,"BaseMeshElement"],[6,"CompositeShape"],[6,"HasAABB"],[6,"BoundingVolume"],[6,"HasBoundingSphere"],[6,"HasBoundingVolume"],[2,"BinaryPartition"],[6,"BVTCostFn"],[6,"BVTVisitor"],[6,"BVTTVisitor"],[6,"PreferedSamplingDirections"],[6,"SupportMap"],[6,"Simplex"],[1,"JohnsonSimplex"],[1,"RecursionTemplate"],[2,"GJKResult"],[1,"Contact"],[1,"CompositeShapeAgainstAnyDistCostFn"],[1,"CompositeShapeAgainstAnyTOICostFn"],[1,"CompoundPointProjCostFn"],[1,"PointContainementTest"],[1,"BaseMeshPointProjCostFn"],[1,"PointContainementTest"],[1,"PointInterferencesCollector"],[1,"Ray"],[1,"RayIntersection"],[1,"CompoundRayToiCostFn"],[1,"CompoundRayToiAndNormalCostFn"],[1,"BaseMeshRayToiCostFn"],[1,"BaseMeshRayToiAndNormalCostFn"],[1,"BaseMeshRayToiAndNormalAndUVsCostFn"],[1,"RayIntersectionCostFn"],[1,"RayInterferencesCollector"],[6,"LocalPointQuery"],[6,"PointQuery"],[6,"RayCast"],[6,"LocalRayCast"],[6,"CollisionDetector"],[6,"ContactSignalHandler"],[6,"CollisionDispatcher"],[6,"BroadPhase"],[1,"CollisionObject"],[1,"PolylinePath"],[1,"NoCap"],[1,"ArrowheadCap"],[1,"PolylinePattern"],[2,"IndexBuffer"],[1,"TriMesh"],[1,"Polyline"],[6,"PolylineCompatibleCap"],[2,"PathSample"],[6,"CurveSampler"],[6,"StrokePattern"],[6,"ToTriMesh"],[6,"ToPolyline"]]};

searchIndex['ncollide_transformation'] = {"items":[[0,"","ncollide_transformation","Geometric entities manipulated by ncollide."],[3,"hacd","","Approximate convex decomposition of a triangle mesh."],[3,"convex_hull3","","Computes the convex hull of a set of 3d points."],[3,"convex_hull2","","Computes the convex hull of a set of 2d points."],[3,"convex_hull2_idx","","Computes the convex hull of a set of 2d points and returns only the indices of the hull\nvertices."],[3,"triangulate","","Triangulates a set of point (sort of) lying on the same 2d plane."],[10,"to_trimesh","ncollide_transformation::to_trimesh::ball_to_trimesh","",0],[10,"to_trimesh","ncollide_transformation::to_trimesh::capsule_to_trimesh","",1],[10,"to_trimesh","ncollide_transformation::to_trimesh::cone_to_trimesh","",2],[10,"to_trimesh","ncollide_transformation::to_trimesh::cuboid_to_trimesh","",3],[10,"to_trimesh","ncollide_transformation::to_trimesh::cylinder_to_trimesh","",4],[10,"to_trimesh","ncollide_transformation::to_trimesh::mesh_to_trimesh","",5],[10,"to_trimesh","ncollide_entities::shape::minkowski_sum","",6],[10,"to_trimesh","ncollide_entities::shape::reflection","",7],[10,"to_trimesh","ncollide_transformation::to_trimesh::triangle_to_trimesh","",8],[10,"to_polyline","ncollide_transformation::to_polyline::ball_to_polyline","",9],[10,"to_polyline","ncollide_transformation::to_polyline::capsule_to_polyline","",10],[10,"to_polyline","ncollide_transformation::to_polyline::cone_to_polyline","",11],[10,"to_polyline","ncollide_transformation::to_polyline::cuboid_to_polyline","",12],[10,"to_polyline","ncollide_transformation::to_polyline::cylinder_to_polyline","",13],[10,"to_polyline","ncollide_entities::shape::minkowski_sum","",6],[10,"to_polyline","ncollide_entities::shape::reflection","",7],[10,"to_polyline","ncollide_transformation::to_polyline::segment_to_polyline","",14],[10,"to_polyline","ncollide_transformation::to_polyline::triangle_to_polyline","",15],[6,"ToTriMesh","ncollide_transformation","Trait implemented by shapes that can be approximated by a triangle mesh."],[9,"to_trimesh","","Builds a triangle mesh from this shape.",16],[6,"ToPolyline","","Trait implemented by shapes that can be approximated by a triangle mesh."],[9,"to_polyline","","Builds a triangle mesh from this shape.",17]],"paths":[[4,"Ball3"],[4,"Capsule3"],[4,"Cone3"],[4,"Cuboid3"],[4,"Cylinder3"],[4,"TriMesh3"],[1,"MinkowskiSum"],[1,"Reflection"],[4,"Triangle3"],[4,"Ball2"],[4,"Capsule2"],[4,"Cone2"],[4,"Cuboid2"],[4,"Cylinder2"],[4,"Segment2"],[4,"Triangle2"],[6,"ToTriMesh"],[6,"ToPolyline"]]};

searchIndex['ncollide_pipeline'] = {"items":[[0,"","ncollide_pipeline","Persistent and time-coherent collision detection."],[0,"broad_phase","","Broad phases."],[1,"DBVTBroadPhase","ncollide_pipeline::broad_phase","Broad phase based on a Dynamic Bounding Volume Tree."],[10,"new","","Creates a new broad phase based on a Dynamic Bounding Volume Tree.",0],[10,"num_interferences","","Number of interferences detected by this broad phase.",0],[10,"defered_add","","",0],[10,"defered_remove","","",0],[10,"update","","",0],[10,"defered_set_bounding_volume","","",0],[10,"interferences_with_bounding_volume","","",0],[10,"interferences_with_ray","","",0],[10,"interferences_with_point","","",0],[6,"BroadPhase","","Trait all broad phase must implement."],[9,"defered_add","","Tells the broad phase to add an element during the next update.",1],[9,"defered_remove","","Tells the broad phase to remove an element during the next update.",1],[9,"defered_set_bounding_volume","","Sets the next bounding volume to be used during the update of this broad phase.",1],[9,"update","","Updates the object additions, removals, and interferences detection.",1],[9,"interferences_with_bounding_volume","","Collects every object which might intersect a given bounding volume.",1],[9,"interferences_with_ray","","Collects every object which might intersect a given ray.",1],[9,"interferences_with_point","","Collects every object which might contain a given point.",1],[0,"narrow_phase","ncollide_pipeline","Collision detection algorithms and structure for the Narrow Phase."],[1,"BallBall","ncollide_pipeline::narrow_phase","Collision detector between two balls."],[1,"PlaneSupportMap","","Collision detector between a plane and a shape implementing the `SupportMap` trait."],[1,"SupportMapPlane","","Collision detector between a plane and a shape implementing the `SupportMap` trait."],[1,"SupportMapSupportMap","","Persistent collision detector between two shapes having a support mapping function."],[1,"IncrementalContactManifoldGenerator","","Contact manifold generator which keeps track of several contacts."],[1,"OneShotContactManifoldGenerator","","Contact manifold generator producing a full manifold at the first update."],[1,"CompositeShapeRepr","","Collision detector between a concave shape and another shape."],[1,"ReprCompositeShape","","Collision detector between a shape and a concave shape."],[1,"BasicCollisionDispatcher","","Collision dispatcher for shapes defined by `ncollide_entities`."],[1,"ContactSignal","","Signal for contact start/stop."],[10,"decode","","",2],[10,"encode","","",2],[10,"clone","","",2],[10,"new","","Creates a new persistent collision detector between two balls.",2],[10,"update","","",2],[10,"num_colls","","",2],[10,"colls","","",2],[10,"decode","","",3],[10,"encode","","",3],[10,"clone","","",3],[10,"new","","Creates a new persistent collision detector between a plane and a shape with a support\nmapping function.",3],[10,"decode","","",4],[10,"encode","","",4],[10,"clone","","",4],[10,"new","","Creates a new persistent collision detector between a plane and a shape with a support\nmapping function.",4],[10,"update","","",3],[10,"num_colls","","",3],[10,"colls","","",3],[10,"update","","",4],[10,"num_colls","","",4],[10,"colls","","",4],[10,"decode","","",5],[10,"encode","","",5],[10,"clone","","",5],[10,"new","","Creates a new persistant collision detector between two shapes with support mapping\nfunctions.",5],[10,"update","","",5],[10,"num_colls","","",5],[10,"colls","","",5],[10,"clone","","",6],[10,"decode","","",6],[10,"encode","","",6],[10,"new","","Creates a new incremental contact manifold generator.",6],[10,"get_sub_collision","","Gets a collision from the sub-detector used by this manifold generator. This does not\nupdate the manifold itself.",6],[10,"add_new_contacts","","Updates the current manifold by adding one point.",6],[10,"update_contacts","","Updates the contacts already existing on this manifold.",6],[10,"update","","",6],[10,"num_colls","","",6],[10,"colls","","",6],[10,"clone","","",7],[10,"decode","","",7],[10,"encode","","",7],[10,"new","","Creates a new one shot contact manifold generator.",7],[10,"update","","",7],[10,"num_colls","","",7],[10,"colls","","",7],[10,"new","","Creates a new collision detector between a concave shape and another shape.",8],[10,"new","","Creates a new collision detector between a shape and a concave shape.",9],[10,"update","","",8],[10,"num_colls","","",8],[10,"colls","","",8],[10,"update","","",9],[10,"num_colls","","",9],[10,"colls","","",9],[10,"new","","Creates a new basic collision dispatcher.",10],[10,"get_collision_algorithm","","",10],[4,"CollisionAlgorithm","",""],[6,"CollisionDetector","","Trait of the algorithms executed during the so-called Narrow Phase."],[9,"update","","Runs the collision detection on two objects. It is assumed that the same\ncollision detector (the same structure) is always used with the same\npair of object.",11],[9,"num_colls","","The number of collision detected during the last update.",11],[9,"colls","","Collects the collisions detected during the last update.",11],[6,"CollisionDispatcher","",""],[9,"get_collision_algorithm","","Allocate a collision algorithm corresponding to the given pair of shapes.",12],[6,"ContactSignalHandler","","A signal handler for contact detection."],[9,"handle_contact","","Activate an action for when two objects start or stop to be close to each other.",13],[0,"world","ncollide_pipeline","High level API to detect collisions in large, complex scenes."],[1,"CollisionObject","ncollide_pipeline::world","A stand-alone object that has a position and a shape."],[11,"position","","The position of the collision object.",14],[11,"shape","","The shape of the collision object.",14],[11,"collision_groups","","The collision groups of the collision object.",14],[11,"data","","The data associated to this object.",14],[1,"CollisionGroups","","30 groups of collision used to filter which object collide with which other one."],[1,"CollisionObjectsDispatcher","","Collision detector dispatcher for collision objects."],[1,"CollisionWorld","","A world that handles collision objects."],[10,"new","","Creates a new collision object.",14],[10,"fmt","","",15],[10,"clone","","",15],[10,"decode","","",15],[10,"encode","","",15],[10,"new","","Creates a new `CollisionGroups` that enables collisions with everything except\nself-collision.",15],[10,"new_with_groups","","Creates a new `CollisionGroups` that enables collisions with the given groups.",15],[10,"new_without_groups","","Creates a new `CollisionGroups` that enables collisions with every group but the given\nones.",15],[10,"enable_collisions_with_all_groups","","Enables collision with all groups.",15],[10,"disable_collisions_with_all_groups","","Disables collision with all groups.",15],[10,"enable_collisions_with_group","","Enable collision detection with a specific group.",15],[10,"disable_collisions_with_group","","Disables collision detection with a specific group.",15],[10,"enable_self_collision","","Enables self collision detection.",15],[10,"disable_self_collision","","Disables self collision detection.",15],[10,"can_collide_with_group","","Tests whether collisions with a given group is enabled.",15],[10,"can_collide_with_groups","","Tests whether two collision groups have at least one group in common.",15],[10,"can_collide_with_self","","Tests whether self-collision is enabled.",15],[10,"new","","Creates a new `CollisionObjectsDispatcher`.",16],[10,"update","","Updates the contact pairs.",16],[10,"contact_pairs","","Iterates through all the contact pairs.",16],[10,"contacts","","Calls a closures on each contact between two objects.",16],[10,"register_contact_signal_handler","","Registers a handler for contact start/stop events.",16],[10,"unregister_contact_signal_handler","","Unregisters a handler for contact start/stop events.",16],[10,"handle_proximity","","Creates/removes the persistant collision detector associated to a given pair of objects.",16],[10,"is_proximity_allowed","","Tests if two objects can be tested for mutual collision.",16],[10,"new","","Creates a new collision world.",17],[10,"add","","Adds a collision object to the world.",17],[10,"remove","","Remove a collision object from the world.",17],[10,"update","","Updates the collision world.",17],[10,"defered_set_position","","Sets the position the collision object attached to the specified object will have during\nthe next update.",17],[10,"register_contact_signal_handler","","Registers a handler for contact start/stop events.",17],[10,"unregister_contact_signal_handler","","Unregisters a handler for contact start/stop events.",17],[10,"perform_position_update","","Executes the position updates.",17],[10,"perform_broad_phase","","Executes the broad phase of the collision detection pipeline.",17],[10,"perform_narrow_phase","","Executes the narrow phase of the collision detection pipeline.",17],[10,"contact_pairs","","Iterats through all the contact pairs.",17],[10,"contacts","","Collects every contact detected since the last update.",17],[10,"interferences_with_ray","","Computes the interferences between every rigid bodies of a given broad phase, and a ray.",17],[10,"interferences_with_point","","Computes the interferences between every rigid bodies of a given broad phase, and a point.",17],[10,"interferences_with_aabb","","Computes the interferences between every rigid bodies of a given broad phase, and a aabb.",17],[4,"BroadPhaseObject","","Type of the broad phase trait-object used by the collision world."]],"paths":[[1,"DBVTBroadPhase"],[6,"BroadPhase"],[1,"BallBall"],[1,"PlaneSupportMap"],[1,"SupportMapPlane"],[1,"SupportMapSupportMap"],[1,"IncrementalContactManifoldGenerator"],[1,"OneShotContactManifoldGenerator"],[1,"CompositeShapeRepr"],[1,"ReprCompositeShape"],[1,"BasicCollisionDispatcher"],[6,"CollisionDetector"],[6,"CollisionDispatcher"],[6,"ContactSignalHandler"],[1,"CollisionObject"],[1,"CollisionGroups"],[1,"CollisionObjectsDispatcher"],[1,"CollisionWorld"]]};

searchIndex['ncollide_queries'] = {"items":[[0,"","ncollide_queries","Geometric queries."],[0,"geometry","","Non-persistant pairwise geometric queries."],[1,"Contact","ncollide_queries::geometry","Geometric description of a contact."],[11,"world1","","Position of the contact on the first object. The position is expressed in world space.",0],[11,"world2","","Position of the contact on the second object. The position is expressed in world space.",0],[11,"normal","","Contact normal",0],[11,"depth","","Penetration depth",0],[3,"contact","","Computes the minimum distance separating two shapes."],[3,"distance","","Computes the minimum distance separating two shapes."],[3,"time_of_impact","","Computes the minimum distance separating two shapes."],[0,"algorithms","","Algorithms needed for distance and penetration depth computation."],[0,"simplex","ncollide_queries::geometry::algorithms","Abstract definition of a simplex usable by the GJK algorithm."],[6,"Simplex","ncollide_queries::geometry::algorithms::simplex","Trait of a simplex usable by the GJK algorithm."],[9,"reset","","Replace the point of the simplex by a single one. The simplex is reduced to be\n0-dimensional.",1],[9,"add_point","","Adds a point to the simplex.",1],[9,"project_origin_and_reduce","","Project the origin on the simplex and remove any sub-simplex which does not contain the\nprojection.",1],[9,"project_origin","","Projection the origin on the simplex. The simplex itself is unchanged, although it is\nmutable for optimization purpose.",1],[9,"contains_point","","Checks whether a given point is already part of the simplex points.",1],[9,"dimension","","Dimension of the simplex. A simplex with `n` must be a `n - 1`-dimensional simplex.",1],[9,"max_sq_len","","The maximum among the simplex point squared lengths.",1],[9,"modify_pnts","","Modifies the points contained by this simplex.",1],[0,"johnson_simplex","ncollide_queries::geometry::algorithms","Simplex using the Johnson subalgorithm to compute the projection of the origin on the simplex."],[1,"JohnsonSimplex","ncollide_queries::geometry::algorithms::johnson_simplex","Simplex using the Johnson subalgorithm to compute the projection of the origin on the simplex."],[1,"RecursionTemplate","","Set of indices to explain to the JohnsonSimplex how to do its work.\nBuilding this is very time consuming, and thus should be shared between all instances of the\nJohnson simplex."],[10,"clone","","",2],[10,"decode","","",3],[10,"encode","","",3],[10,"clone","","",3],[10,"eq","","",3],[10,"ne","","",3],[10,"new","","Creates a new set of Recursion simplex sharable between any Johnson simplex having a\ndimension inferior or equal to `dim`.",3],[10,"new","","Creates a new, empty, Johnson simplex.",2],[10,"new_w_tls","","Creates a new, empty Johnson simplex. The recursion template uses the thread-local one.",2],[10,"reset","","",2],[10,"dimension","","",2],[10,"max_sq_len","","",2],[10,"contains_point","","",2],[10,"add_point","","",2],[10,"project_origin_and_reduce","","",2],[10,"project_origin","","",2],[10,"modify_pnts","","",2],[0,"gjk","ncollide_queries::geometry::algorithms","The Gilbert–Johnson–Keerthi distance algorithm."],[2,"GJKResult","ncollide_queries::geometry::algorithms::gjk","Results of the GJK algorithm."],[12,"Intersection","","Result of the GJK algorithm when the origin is inside of the polytope.",4],[12,"Projection","","Result of the GJK algorithm when a projection of the origin on the polytope is found.",4],[12,"NoIntersection","","Result of the GJK algorithm when the origin is to far away from the polytope.",4],[3,"closest_points","","Computes the closest points between two convex shapes unsing the GJK\nalgorithm."],[3,"closest_points_with_max_dist","","Computes the closest points between two convex shapes unsing the GJK algorithm."],[3,"distance","","Computes the exact distance separating two convex shapes unsing the GJK.\nalgorithm."],[3,"project_origin","","Projects the origin on a shape unsing the GJK algorithm."],[3,"project_origin_with_max_dist","","Projects the origin on a shape using the Separating Axis GJK algorithm.\nThe algorithm will stop as soon as the polytope can be proven to be at least `max_dist` away\nfrom the origin."],[3,"cast_ray","","Casts a ray on a support map using the GJK algorithm."],[10,"clone","","",4],[10,"decode","","",4],[10,"encode","","",4],[0,"minkowski_sampling","ncollide_queries::geometry::algorithms","Penetration depth computation algorithm approximating the Minkowskis sum."],[3,"closest_points","ncollide_queries::geometry::algorithms::minkowski_sampling","Computes the closest points between two implicit inter-penetrating shapes. Returns None if the\nshapes are not in penetration. This can be used as a fallback algorithm for the GJK algorithm."],[3,"project_origin","","Projects the origin on a support-mapped shape."],[0,"contacts_internal","ncollide_queries::geometry","Implementation details of the `contact` and `contacts` functions."],[3,"ball_against_ball","ncollide_queries::geometry::contacts_internal","Contact between balls."],[3,"support_map_against_support_map","","Contact between support-mapped shapes (`Cuboid`, `Convex`, etc.)"],[3,"support_map_against_support_map_with_params","","Contact between support-mapped shapes (`Cuboid`, `Convex`, etc.)"],[3,"plane_against_support_map","","Contact between a plane and a support-mapped shape (Cuboid, Convex, etc.)"],[3,"support_map_against_plane","","Contact between a support-mapped shape (Cuboid, Convex, etc.) and a plane."],[3,"composite_shape_against_any","","Best contact between a composite shape (`Mesh`, `Compound`) and any other shape."],[3,"any_against_composite_shape","","Best contact between a shape and a composite (`Mesh`, `Compound`) shape."],[10,"decode","ncollide_queries::geometry","",0],[10,"encode","","",0],[10,"clone","","",0],[10,"eq","","",0],[10,"ne","","",0],[10,"fmt","","",0],[10,"new","","Creates a new contact.",0],[10,"flip","","Reverts the contact normal and swaps `world1` and `world2`.",0],[0,"distance_internal","","Implementation details of the `distance` function."],[3,"ball_against_ball","ncollide_queries::geometry::distance_internal","Distance between balls."],[3,"support_map_against_support_map","","Distance between support-mapped shapes."],[3,"support_map_against_support_map_with_params","","Distance between support-mapped shapes."],[3,"plane_against_support_map","","Distance between a plane and a support-mapped shape."],[3,"support_map_against_plane","","Distance between a support-mapped shape and a plane."],[3,"composite_shape_against_any","","Smallest distance between a composite shape and any other shape."],[3,"any_against_composite_shape","","Smallest distance between a shape and a composite shape."],[0,"time_of_impact_internal","ncollide_queries::geometry","Implementation details of the `distance` function."],[3,"ball_against_ball","ncollide_queries::geometry::time_of_impact_internal","Time Of Impact of two balls under translational movement."],[3,"support_map_against_support_map","","Time of impacts between two support-mapped shapes under translational movement."],[3,"plane_against_support_map","","Time Of Impact of a plane with a support-mapped shape under translational movement."],[3,"support_map_against_plane","","Time Of Impact of a plane with a support-mapped shape under translational movement."],[3,"composite_shape_against_any","","Time Of Impact of a composite shape with any other shape, under translational movement."],[3,"any_against_composite_shape","","Time Of Impact of any shape with a composite shape, under translational movement."],[0,"point","ncollide_queries","Point inclusion and projection."],[1,"PointInterferencesCollector","ncollide_queries::point","Bounding Volume Tree visitor collecting nodes that may contain a given point."],[10,"project_point","ncollide_entities::shape::plane","",5],[10,"distance_to_point","","",5],[10,"contains_point","","",5],[10,"project_point","ncollide_entities::shape::ball","",6],[10,"distance_to_point","","",6],[10,"contains_point","","",6],[10,"project_point","ncollide_entities::shape::cuboid","",7],[10,"distance_to_point","","",7],[10,"contains_point","","",7],[10,"project_point","ncollide_entities::bounding_volume::aabb","",8],[10,"distance_to_point","","",8],[10,"contains_point","","",8],[10,"project_point","ncollide_entities::bounding_volume::bounding_sphere","",9],[10,"distance_to_point","","",9],[10,"contains_point","","",9],[10,"project_point","ncollide_entities::shape::cylinder","",10],[10,"distance_to_point","","",10],[10,"contains_point","","",10],[10,"project_point","ncollide_entities::shape::cone","",11],[10,"distance_to_point","","",11],[10,"contains_point","","",11],[10,"project_point","ncollide_entities::shape::capsule","",12],[10,"distance_to_point","","",12],[10,"contains_point","","",12],[10,"project_point","ncollide_entities::shape::convex","",13],[10,"distance_to_point","","",13],[10,"contains_point","","",13],[10,"project_point","ncollide_entities::shape::minkowski_sum","",14],[10,"distance_to_point","","",14],[10,"contains_point","","",14],[10,"project_point","ncollide_entities::shape::segment","",15],[10,"distance_to_point","","",15],[10,"contains_point","","",15],[10,"project_point","ncollide_entities::shape::triangle","",16],[10,"distance_to_point","","",16],[10,"contains_point","","",16],[10,"project_point","ncollide_entities::shape::compound","",17],[10,"distance_to_point","","",17],[10,"contains_point","","",17],[10,"project_point","ncollide_entities::shape::base_mesh","",18],[10,"distance_to_point","","",18],[10,"contains_point","","",18],[10,"project_point","ncollide_entities::shape::trimesh","",19],[10,"distance_to_point","","",19],[10,"contains_point","","",19],[10,"project_point","ncollide_entities::shape::polyline","",20],[10,"distance_to_point","","",20],[10,"contains_point","","",20],[10,"project_point","ncollide_queries::point","",21],[10,"distance_to_point","","",21],[10,"contains_point","","",21],[10,"new","","Creates a new `PointInterferencesCollector`.",22],[10,"visit_internal","","",22],[10,"visit_leaf","","",22],[6,"LocalPointQuery","","Trait of objects that can be tested for point inclusion and projection."],[9,"project_point","","Projects a point on `self`.",23],[9,"distance_to_point","","Computes the minimal distance between a point and `self`.",23],[9,"contains_point","","Tests if the given point is inside of `self`.",23],[6,"PointQuery","","Trait of objects that can be transformed and tested for point inclusion and projection."],[10,"project_point_with_transform","","Projects a point on `self` transformed by `m`.",24],[10,"distance_to_point_with_transform","","Computes the minimal distance between a point and `self` transformed by `m`.",24],[10,"contains_point_with_transform","","Tests if the given point is inside of `self` transformed by `m`.",24],[0,"ray","ncollide_queries","Ray-casting related definitions and implementations."],[1,"Ray","ncollide_queries::ray","A Ray."],[11,"orig","","Starting point of the ray.",25],[11,"dir","","Direction of the ray.",25],[1,"RayIntersection","","Structure containing the result of a successful ray cast."],[11,"toi","","The time of impact of the ray with the object.  The exact contact point can be computed\nwith: `orig + dir * toi` where `orig` is the origin of the ray; `dir` is its direction and\n`toi` is the value of this field.",26],[11,"normal","","The normal at the intersection point.",26],[11,"uvs","","The textures coordinates at the intersection point.  This is an `Option` because some shape\ndo not support texture coordinates.",26],[1,"RayIntersectionCostFn","","A search thet selects the objects that has the smallest time of impact with a given ray."],[1,"RayInterferencesCollector","","Bounding Volume Tree visitor collecting interferences with a given ray."],[3,"plane_toi_with_ray","","Computes the toi of a ray with a plane described by its center and normal."],[3,"triangle_ray_intersection","","Computes the intersection between a triangle and a ray."],[3,"implicit_toi_and_normal_with_ray","","Cast a ray on a shape using the GJK algorithm."],[3,"ball_toi_with_ray","","Computes the time of impact of a ray on a ball."],[10,"toi_and_normal_with_ray","ncollide_entities::shape::plane","",5],[10,"toi_with_ray","ncollide_entities::shape::ball","",6],[10,"toi_and_normal_with_ray","","",6],[10,"toi_and_normal_and_uv_with_ray","","",6],[10,"toi_with_transform_and_ray","","",6],[10,"toi_with_ray","ncollide_entities::shape::cuboid","",7],[10,"toi_and_normal_with_ray","","",7],[10,"toi_and_normal_and_uv_with_ray","","",7],[10,"toi_with_ray","ncollide_entities::bounding_volume::aabb","",8],[10,"toi_and_normal_with_ray","","",8],[10,"toi_and_normal_and_uv_with_ray","","",8],[10,"toi_with_ray","ncollide_entities::bounding_volume::bounding_sphere","",9],[10,"toi_and_normal_with_ray","","",9],[10,"toi_and_normal_and_uv_with_ray","","",9],[10,"intersects_ray","","",9],[10,"toi_and_normal_with_ray","ncollide_entities::shape::cylinder","",10],[10,"toi_and_normal_with_ray","ncollide_entities::shape::cone","",11],[10,"toi_and_normal_with_ray","ncollide_entities::shape::capsule","",12],[10,"toi_and_normal_with_ray","ncollide_entities::shape::convex","",13],[10,"toi_and_normal_with_ray","ncollide_entities::shape::segment","",15],[10,"toi_and_normal_with_ray","ncollide_entities::shape::minkowski_sum","",14],[10,"toi_and_normal_with_ray","ncollide_entities::shape::triangle","",16],[10,"toi_with_ray","ncollide_entities::shape::compound","",17],[10,"toi_and_normal_with_ray","","",17],[10,"toi_with_ray","ncollide_entities::shape::base_mesh","",18],[10,"toi_and_normal_with_ray","","",18],[10,"toi_and_normal_and_uv_with_ray","","",18],[10,"toi_with_ray","ncollide_entities::shape::trimesh","",19],[10,"toi_and_normal_with_ray","","",19],[10,"toi_and_normal_and_uv_with_ray","","",19],[10,"toi_with_ray","ncollide_entities::shape::polyline","",20],[10,"toi_and_normal_with_ray","","",20],[10,"toi_and_normal_and_uv_with_ray","","",20],[10,"toi_with_ray","ncollide_queries::ray","",21],[10,"toi_and_normal_with_ray","","",21],[10,"toi_and_normal_and_uv_with_ray","","",21],[10,"intersects_ray","","",21],[10,"new","","Creates a new `BestRayInterferenceSearch`.",27],[10,"compute_bv_cost","","",27],[10,"compute_b_cost","","",27],[10,"new","","Creates a new `RayInterferencesCollector`.",28],[10,"visit_internal","","",28],[10,"visit_leaf","","",28],[4,"Ray3","","A 3D ray."],[4,"Ray2","","A 2D ray."],[4,"RayIntersection3","","A 3D ray intersection."],[4,"RayIntersection2","","A 2D ray intersection."],[6,"LocalRayCast","","Traits of objects which can be tested for intersection with a ray."],[10,"toi_with_ray","","Computes the time of impact between this shape and a ray",29],[9,"toi_and_normal_with_ray","","Computes the intersection point between this shape and a ray.",29],[10,"toi_and_normal_and_uv_with_ray","","Computes the intersection point and normal between this shape and a ray.",29],[10,"intersects_ray","","Tests whether a ray intersects this shape.",29],[6,"RayCast","","Traits of objects which can be transformed and tested for intersection with a ray."],[10,"toi_with_transform_and_ray","","Computes the time of impact between this transform shape and a ray.",30],[10,"toi_and_normal_with_transform_and_ray","","Computes the time of impact, and normal between this transformed shape and a ray.",30],[10,"toi_and_normal_and_uv_with_transform_and_ray","","Computes time of impact, normal, and texture coordinates (uv) between this transformed\nshape and a ray.",30],[10,"intersects_with_transform_and_ray","","Tests whether a ray intersects this transformed shape.",30]],"paths":[[1,"Contact"],[6,"Simplex"],[1,"JohnsonSimplex"],[1,"RecursionTemplate"],[2,"GJKResult"],[1,"Plane"],[1,"Ball"],[1,"Cuboid"],[1,"AABB"],[1,"BoundingSphere"],[1,"Cylinder"],[1,"Cone"],[1,"Capsule"],[1,"Convex"],[1,"MinkowskiSum"],[1,"Segment"],[1,"Triangle"],[1,"Compound"],[1,"BaseMesh"],[1,"TriMesh"],[1,"Polyline"],[6,"Repr"],[1,"PointInterferencesCollector"],[6,"LocalPointQuery"],[6,"PointQuery"],[1,"Ray"],[1,"RayIntersection"],[1,"RayIntersectionCostFn"],[1,"RayInterferencesCollector"],[6,"LocalRayCast"],[6,"RayCast"]]};

searchIndex['ncollide_entities'] = {"items":[[0,"","ncollide_entities","Geometric entities manipulated by ncollide."],[0,"shape","","Collision shapes supported by ncollide."],[1,"Ball","ncollide_entities::shape","A Ball shape."],[1,"Plane","","SupportMap description of a plane."],[1,"Cuboid","","Shape of a box."],[1,"Capsule","","SupportMap description of a capsule shape with its principal axis aligned with the `y` axis."],[1,"Cone","","SupportMap description of a cylinder shape with its principal axis aligned with the `y` axis."],[1,"Cylinder","","SupportMap description of a cylinder shape with its principal axis aligned with the `y` axis."],[1,"Convex","","The implicit convex hull of a set of points."],[1,"MinkowskiSum","","SupportMap representation of the Minkowski sum of two shapes."],[1,"AnnotatedMinkowskiSum","","Same as the MinkowskiSum but with a support mapping which keeps track of the\noriginal supports points from the two wrapped shapes."],[1,"Reflection","","SupportMap representation of the reflection of a shape."],[1,"Compound","","A compound shape with an aabb bounding volume."],[1,"BaseMesh","","A mesh generic wrt. the contained mesh elements characterized by vertices."],[1,"TriMesh","","Shape commonly known as a 2d line strip or a 3d triangle mesh."],[1,"Polyline","","Shape commonly known as a 2d line strip or a 3d segment mesh."],[1,"Segment","","A segment shape."],[1,"Triangle","","A triangle shape."],[1,"Torus","","A torus."],[10,"decode","","",0],[10,"encode","","",0],[10,"clone","","",0],[10,"fmt","","",0],[10,"eq","","",0],[10,"ne","","",0],[10,"new","","Builds a new plane from its center and its normal.",0],[10,"new_normalized","","Builds a new plane from its center and its normal.",0],[10,"normal","","The plane normal.",0],[10,"decode","","",1],[10,"encode","","",1],[10,"clone","","",1],[10,"fmt","","",1],[10,"eq","","",1],[10,"ne","","",1],[10,"new","","Creates a new box from its half-extents. Half-extents are the box half-width along each\naxis. Each half-extent must be greater than 0.04.",1],[10,"half_extents","","The half-extents of this box. Half-extents are the box half-width along each axis.",1],[10,"fmt","","",2],[10,"new","","Builds the Minkowski sum of two shapes. Since the representation is\nimplicit, this is done in constant time.",2],[10,"m1","","The transformation matrix of the first shape of this Minkowski Sum.",2],[10,"m2","","The transformation matrix of the second shape of this Minkowski Sum.",2],[10,"g1","","The first shape of this Minkowski Sum.",2],[10,"g2","","The second shape of this Minkowski Sum.",2],[10,"fmt","","",3],[10,"new","","Builds the Minkowski sum of two shapes. Since the representation is\nimplicit, this is done in constant time.",3],[10,"m1","","The transformation matrix of the first shape of this Minkowski Sum.",3],[10,"m2","","The transformation matrix of the second shape of this Minkowski Sum.",3],[10,"g1","","The first shape of this Minkowski Sum.",3],[10,"g2","","The second shape of this Minkowski Sum.",3],[10,"decode","","",4],[10,"encode","","",4],[10,"clone","","",4],[10,"fmt","","",4],[10,"eq","","",4],[10,"ne","","",4],[10,"new","","Creates a new segment from two points.",4],[10,"a","","The first point of this segment.",4],[10,"b","","The second point of this segment.",4],[10,"new_with_vertices_and_indices","","",4],[10,"decode","","",5],[10,"encode","","",5],[10,"clone","","",5],[10,"fmt","","",5],[10,"eq","","",5],[10,"ne","","",5],[10,"new","","Creates a triangle from three points.",5],[10,"a","","The fist point of this triangle.",5],[10,"b","","The second point of this triangle.",5],[10,"c","","The third point of this triangle.",5],[10,"new_with_vertices_and_indices","","",5],[10,"clone","","",6],[10,"new","","Builds a new mesh.",6],[10,"vertices","","The vertices of this mesh.",6],[10,"bounding_volumes","","Bounding volumes of the subsimplices.",6],[10,"indices","","The indices of this mesh.",6],[10,"uvs","","The texture coordinates of this mesh.",6],[10,"normals","","The normals of this mesh.",6],[10,"bvt","","The acceleration structure used for efficient collision detection and ray casting.",6],[10,"element_at","","Gets the i-th mesh element.",6],[10,"clone","","",7],[10,"new","","Builds a new mesh.",7],[10,"base_mesh","","The base representation of this mesh.",7],[10,"vertices","","The vertices of this mesh.",7],[10,"bounding_volumes","","Bounding volumes of the subsimplices.",7],[10,"indices","","The indices of this mesh.",7],[10,"uvs","","The texture coordinates of this mesh.",7],[10,"normals","","The normals of this mesh.",7],[10,"bvt","","The acceleration structure used for efficient collision detection and ray casting.",7],[10,"triangle_at","","Gets the i-th mesh element.",7],[10,"clone","","",8],[10,"new","","Builds a new mesh.",8],[10,"base_mesh","","The base representation of this mesh.",8],[10,"vertices","","The vertices of this mesh.",8],[10,"bounding_volumes","","Bounding volumes of the subsimplices.",8],[10,"indices","","The indices of this mesh.",8],[10,"uvs","","The texture coordinates of this mesh.",8],[10,"normals","","The normals of this mesh.",8],[10,"bvt","","The acceleration structure used for efficient collision detection and ray casting.",8],[10,"segment_at","","Gets the i-th mesh element.",8],[10,"decode","","",9],[10,"encode","","",9],[10,"clone","","",9],[10,"fmt","","",9],[10,"eq","","",9],[10,"ne","","",9],[10,"new","","Creates a new ball from its radius and center.",9],[10,"radius","","The ball radius.",9],[10,"decode","","",10],[10,"encode","","",10],[10,"clone","","",10],[10,"fmt","","",10],[10,"eq","","",10],[10,"ne","","",10],[10,"new","","Creates a new capsule.",10],[10,"half_height","","The capsule half length along the `y` axis.",10],[10,"radius","","The radius of the capsule's rounded part.",10],[10,"decode","","",11],[10,"encode","","",11],[10,"clone","","",11],[10,"fmt","","",11],[10,"eq","","",11],[10,"ne","","",11],[10,"new","","Creates a new cone.",11],[10,"half_height","","The cone half length along the `y` axis.",11],[10,"radius","","The radius of the cone along all but the `y` axis.",11],[10,"decode","","",12],[10,"encode","","",12],[10,"clone","","",12],[10,"fmt","","",12],[10,"eq","","",12],[10,"ne","","",12],[10,"new","","Creates a new cylinder.",12],[10,"half_height","","The cylinder half length along the `y` axis.",12],[10,"radius","","The radius of the cylinder along all but the `y` axis.",12],[10,"fmt","","",13],[10,"new","","Build the reflection of a shape. Since the representation is implicit,\nthe reflection computation is done in constant time.",13],[10,"shape","","The reflected shape.",13],[10,"decode","","",14],[10,"encode","","",14],[10,"clone","","",14],[10,"fmt","","",14],[10,"eq","","",14],[10,"ne","","",14],[10,"new","","Creates a new torus with the given radiuses.",14],[10,"minor_radius","","The torus minor radius.",14],[10,"major_radius","","The torus major radius.",14],[10,"clone","","",15],[10,"new","","Builds a new compound shape.",15],[10,"shapes","","The shapes of this compound shape.",15],[10,"bvt","","The optimization structure used by this compound shape.",15],[10,"bounding_volumes","","The shapes bounding volumes.",15],[10,"aabb_at","","The AABB of the i-th shape compositing this compound.",15],[10,"decode","","",16],[10,"encode","","",16],[10,"clone","","",16],[10,"fmt","","",16],[10,"eq","","",16],[10,"ne","","",16],[10,"new","","Creates a polytope from a set of point.",16],[10,"points","","The list of points of this convex polytope.",16],[10,"map_part_at","","",15],[10,"map_transformed_part_at","","",15],[10,"aabb_at","","",15],[10,"bvt","","",15],[10,"map_part_at","","",7],[10,"map_transformed_part_at","","",7],[10,"aabb_at","","",7],[10,"bvt","","",7],[10,"map_part_at","","",8],[10,"map_transformed_part_at","","",8],[10,"aabb_at","","",8],[10,"bvt","","",8],[4,"Ball2","","A 2D ball."],[4,"Plane2","","A 2D plane."],[4,"Cuboid2","","A 2D cuboid."],[4,"Capsule2","","A 2D capsule."],[4,"Cone2","","A 2D cone."],[4,"Cylinder2","","A 2D cylinder."],[4,"Convex2","","A 2D convex polytope."],[4,"Segment2","","A 2D segment."],[4,"Triangle2","","A 2D triangle."],[4,"Polyline2","","A 2D polyline."],[4,"Compound2","","A 2D compound shape."],[4,"Ball3","","A 3D ball."],[4,"Plane3","","A 3D plane."],[4,"Cuboid3","","A 3D cuboid."],[4,"Capsule3","","A 3D capsule."],[4,"Cone3","","A 3D cone."],[4,"Cylinder3","","A 3D cylinder."],[4,"Convex3","","A 3D convex polytope."],[4,"Segment3","","A 3D segment."],[4,"Triangle3","","A 3D triangle."],[4,"Polyline3","","A 3D polyline."],[4,"TriMesh3","","A 3D triangle mesh."],[4,"Compound3","","A 3D compound shape."],[6,"BaseMeshElement","","Trait implemented by elements usable on the Mesh."],[9,"new_with_vertices_and_indices","","Creates a new mesh element from a set of vertices and indices.",17],[6,"CompositeShape","","Trait implemented by shapes composed of multiple simpler shapes."],[9,"map_part_at","","Applies a function to each sub-shape of this concave shape.",18],[9,"map_transformed_part_at","","Applies a transformation matrix and a function to each sub-shape of this concave\nshape.",18],[9,"aabb_at","","Gets the AABB of the shape identified by the index `i`.",18],[9,"bvt","","Gets the acceleration structure of the concave shape.",18],[0,"support_map","ncollide_entities","Definition of support functions."],[3,"cso_support_point","ncollide_entities::support_map","Computes the support point of the CSO `g1 - g2` on a given direction."],[3,"point_cloud_support_point","","Computes the support point of a cloud of points."],[10,"support_point","ncollide_entities::shape","",1],[10,"sample","","",1],[10,"support_point","","",9],[10,"sample","","",9],[10,"support_point","","",10],[10,"sample","","",10],[10,"support_point","","",11],[10,"sample","","",11],[10,"support_point","","",12],[10,"sample","","",12],[10,"support_point","","",16],[10,"sample","","",16],[10,"support_point","","",13],[10,"sample","","Applies a function to this shape with a given transform.",13],[10,"support_point","","",5],[10,"sample","","",5],[10,"support_point","","",4],[10,"sample","","",4],[10,"support_point","","",2],[10,"support_point","","",3],[10,"sample","","",2],[10,"sample","","",3],[6,"SupportMap","ncollide_entities::support_map","Traits of convex shapes representable by a support mapping function."],[9,"support_point","","Evaluates the support function of the object. A support function is a\nfunction associating a vector to the shape point which maximizes their\ndot product. This does not include the `margin` of the object. Margins are\nshape-dependent. Use `support_point` to sample the complete shape.",19],[6,"PreferedSamplingDirections","","Trait of shapes having prefered sampling directions for the Minkowski sampling algorithm."],[9,"sample","","Applies a function to this shape with a given transform.",20],[0,"bounding_volume","ncollide_entities","Bounding volumes."],[1,"AABB","ncollide_entities::bounding_volume","An Axis Aligned Bounding Box."],[1,"BoundingSphere","","A Bounding Sphere."],[1,"BoundingVolumeInterferencesCollector","","Bounding Volume Tree visitor collecting interferences with a given bounding volume."],[3,"implicit_shape_aabb","","Computes the AABB of an support mapped shape."],[3,"point_cloud_aabb","","Computes the AABB of a set of point."],[3,"ball_aabb","","Computes the Axis-Aligned Bounding Box of a ball."],[3,"point_cloud_bounding_sphere_with_center","","Computes the bounding sphere of a set of point, given its center."],[3,"point_cloud_bounding_sphere","","Computes a bounding sphere of the specified set of point."],[10,"new","","Creates a new `BoundingVolumeInterferencesCollector`.",21],[10,"visit_internal","","",21],[10,"visit_leaf","","",21],[10,"aabb","ncollide_entities::shape","",1],[10,"aabb","","",11],[10,"aabb","","",12],[10,"aabb","","",10],[10,"aabb","","",5],[10,"aabb","","",4],[10,"aabb","","",9],[10,"aabb","","",0],[10,"aabb","","",16],[10,"aabb","","",15],[10,"aabb","","",6],[10,"aabb","","",7],[10,"aabb","","",8],[10,"bounding_sphere","","",1],[10,"bounding_sphere","","",11],[10,"bounding_sphere","","",9],[10,"bounding_sphere","","",12],[10,"bounding_sphere","","",10],[10,"bounding_sphere","","",0],[10,"bounding_sphere","","",16],[10,"bounding_sphere","","",15],[10,"bounding_sphere","","",5],[10,"bounding_sphere","","",4],[10,"bounding_sphere","","",6],[10,"bounding_sphere","","",7],[10,"bounding_sphere","","",8],[4,"BoundingSphere2","ncollide_entities::bounding_volume","A 2D bounding sphere."],[4,"AABB2","","A 2D AABB."],[4,"BoundingSphere3","","A 3D bounding sphere:"],[4,"AABB3","","A 3D AABB."],[6,"HasBoundingVolume","","Traits of objects having a bounding volume."],[9,"bounding_volume","","The object bounding volume.",22],[6,"BoundingVolume","","Trait of bounding volumes."],[9,"intersects","","Checks if this bounding volume intersect with another one.",23],[9,"contains","","Checks if this bounding volume contains another one.",23],[9,"merge","","Merges this bounding volume with another one. The merge is done in-place.",23],[9,"merged","","Merges this bounding volume with another one.",23],[9,"loosen","","Enlarges this bounding volume.",23],[9,"loosened","","Creates a new, enlarged version, of this bounding volume.",23],[9,"tighten","","Tighten this bounding volume.",23],[9,"tightened","","Creates a new, tightened version, of this bounding volume.",23],[6,"HasAABB","","Trait of objects that can be bounded by an AABB."],[9,"aabb","","The object’s AABB.",24],[6,"HasBoundingSphere","","Trait implemented by objects having a bounding sphere."],[9,"bounding_sphere","","The object bounding sphere.",25],[0,"partitioning","ncollide_entities","Spatial partitioning tools."],[1,"DBVT","ncollide_entities::partitioning","A Dynamic Bounding Volume Tree."],[1,"DBVTLeaf","","Leaf of a Dynamic Bounding Volume Tree."],[11,"bounding_volume","","The bounding volume of this node.",26],[11,"center","","The center of this node bounding volume.",26],[11,"object","","An user-defined object.",26],[1,"BVT","","A Boundig Volume Tree."],[1,"BoundingVolumeInterferencesCollector","","Bounding Volume Tree visitor collecting interferences with a given bounding volume."],[2,"BinaryPartition","","Result of a binary partition."],[12,"Part","","Result of the partitioning of one element.",27],[12,"Parts","","Result of the partitioning of several elements.",27],[2,"BVTNode","","A node of the bounding volume tree."],[12,"Internal","","An internal node.",28],[12,"Leaf","","A leaf.",28],[3,"median_partitioner","","Construction function for a kdree to be used with `BVT::new_with_partitioner`."],[3,"median_partitioner_with_centers","","Construction function for a kdree to be used with `BVT::new_with_partitioner`."],[10,"new","","Creates a new Dynamic Bounding Volume Tree.",29],[10,"remove","","Removes a leaf from the tree. Fails if the tree is empty.",29],[10,"insert_new","","Creates, inserts, and returns a new leaf with the given content.",29],[10,"insert","","Inserts a leaf to the tree.",29],[10,"visit","","Visit this tree using… a visitor!",29],[10,"clone","","",26],[10,"new","","Creates a new leaf.",26],[10,"is_root","","Tests if this node is the root.",26],[10,"is_detached","","Tests if this node has no parent.",26],[10,"decode","","",30],[10,"encode","","",30],[10,"clone","","",30],[10,"decode","","",28],[10,"encode","","",28],[10,"clone","","",28],[10,"new_with_partitioner","","Builds a bounding volume tree using an user-defined construction function.",30],[10,"visit","","Visit this tree using… a visitor!",30],[10,"visit_bvtt","","Visits the bounding volume traversal tree implicitely formed with `other`.",30],[10,"best_first_search","","Performs a best-fist-search on the tree.",30],[10,"root_bounding_volume","","Reference to the bounding volume of the tree root.",30],[10,"depth","","Computes the depth of this tree.",30],[10,"new_balanced","","Creates a balanced `BVT`.",30],[10,"bounding_volume","","The bounding volume of this node.",28],[6,"BVTVisitor","","Visitor of Bounding Volume Trees."],[9,"visit_internal","","Visits an internal node. Returns `true` if the internal node children have to be visited\ntoo.",31],[9,"visit_leaf","","Visits a leaf.",31],[6,"BVTTVisitor","","Visitor for the Bounding Volume Traversal Tree."],[9,"visit_internal_internal","","Visit two internal nodes.",32],[9,"visit_leaf_leaf","","Visit two leaves.",32],[9,"visit_internal_leaf","","Visit one internal node and one leaf.",32],[9,"visit_leaf_internal","","Visit one leaf and on internal node.",32],[6,"BVTCostFn","","Trait implemented by cost functions used by the best-first search on a `BVT`."],[9,"compute_bv_cost","","Computes the cost of a bounding volume.",33],[9,"compute_b_cost","","Computes the cost of an object, and the result to be returned if it is the best one.",33],[0,"inspection","ncollide_entities","Traits and methods to inspect and retrieve the capabilities and representations of shapes at runtime."],[3,"maybe_as_composite_shape","ncollide_entities::inspection","Converts a shape to a composite shape if possible."],[3,"maybe_repr_desc_as_composite_shape","","Converts a shape to a composite shape if possible."],[3,"composite_shape_repr_id","","Gets the id associated with the `CompositeShape` trait."],[3,"maybe_as_support_map","","Converts a shape to a support map if possible."],[3,"maybe_repr_desc_as_support_map","","Converts a shape descriptor to a support map if possible."],[3,"support_map_repr_id","","Gets the id associated with the `SupportMap` trait."],[4,"Repr2","","A 2d dynamic representation object."],[4,"Repr3","","A 3d dynamic representation object."]],"paths":[[1,"Plane"],[1,"Cuboid"],[1,"MinkowskiSum"],[1,"AnnotatedMinkowskiSum"],[1,"Segment"],[1,"Triangle"],[1,"BaseMesh"],[1,"TriMesh"],[1,"Polyline"],[1,"Ball"],[1,"Capsule"],[1,"Cone"],[1,"Cylinder"],[1,"Reflection"],[1,"Torus"],[1,"Compound"],[1,"Convex"],[6,"BaseMeshElement"],[6,"CompositeShape"],[6,"SupportMap"],[6,"PreferedSamplingDirections"],[1,"BoundingVolumeInterferencesCollector"],[6,"HasBoundingVolume"],[6,"BoundingVolume"],[6,"HasAABB"],[6,"HasBoundingSphere"],[1,"DBVTLeaf"],[2,"BinaryPartition"],[2,"BVTNode"],[1,"DBVT"],[1,"BVT"],[6,"BVTVisitor"],[6,"BVTTVisitor"],[6,"BVTCostFn"]]};

searchIndex['ncollide_procedural'] = {"items":[[0,"","ncollide_procedural","Procedural mesh generation."],[1,"TriMesh","","Shapeetric description of a mesh."],[11,"coords","","Coordinates of the mesh vertices.",0],[11,"normals","","Coordinates of the mesh normals.",0],[11,"uvs","","Textures coordinates of the mesh.",0],[11,"indices","","Index buffer of the mesh.",0],[1,"Polyline","","Shapeetric description of a polyline."],[11,"coords","","Coordinates of the polyline vertices.",1],[11,"normals","","Coordinates of the polyline normals.",1],[2,"IndexBuffer","","Different representations of the index buffer."],[12,"Unified","","The vertex, normal, and uvs share the same indices.",2],[12,"Split","","The vertex, normal, and uvs have different indices.",2],[3,"bezier_surface","","Given a set of control points, generates a (non-rational) Bezier surface."],[3,"bezier_curve","","Given a set of control points, generates a (non-rational) Bezier curve."],[3,"capsule","","Generates a capsule."],[3,"unit_cone","","Generates a cone with unit height and diameter."],[3,"cone","","Generates a cone with a given height and diameter."],[3,"cuboid","","Generates a cuboid shape with a split index buffer."],[3,"unit_cuboid","","Generates a cuboid shape with a split index buffer."],[3,"rectangle","","The contour of a cuboid lying on the x-y plane."],[3,"unit_rectangle","","The contour of a unit cuboid lying on the x-y plane."],[3,"unit_cylinder","","Generates a cylinder with unit height and diameter."],[3,"cylinder","","Generates a cylinder with a given height and diameter."],[3,"quad","","Adds a double-sided quad to the scene."],[3,"unit_quad","","Adds a double-sided quad with unit size to the scene."],[3,"quad_with_vertices","","Adds a double-sided quad with the specified grid of vertices."],[3,"sphere","","Generates a UV sphere."],[3,"unit_sphere","","Generates a UV sphere centered at the origin and with a unit diameter."],[3,"circle","","Creates a circle lying on the `(x,y)` plane."],[3,"unit_circle","","Creates a circle lying on the `(x,y)` plane."],[3,"unit_hemisphere","","Creates an hemisphere with a diameter of 1."],[0,"utils","","Utilities useful for various generations tasks."],[3,"push_circle","ncollide_procedural::utils","Pushes a discretized counterclockwise circle to a buffer."],[3,"push_xy_arc","","Pushes a discretized counterclockwise circle to a buffer.\nThe circle is contained on the plane spanned by the `x` and `y` axis."],[3,"push_ring_indices","","Creates the faces from two circles with the same discretization."],[3,"push_open_ring_indices","","Creates the faces from two circles with the same discretization."],[3,"push_degenerate_top_ring_indices","","Creates the faces from a circle and a point that is shared by all triangle."],[3,"push_degenerate_open_top_ring_indices","","Creates the faces from a circle and a point that is shared by all triangle."],[3,"push_filled_circle_indices","","Pushes indices so that a circle is filled with triangles. Each triangle will have the\n`base_circle` point in common.\nPushes `nsubdiv - 2` elements to `out`."],[3,"push_rectangle_indices","","Given four corner points, pushes to two counterclockwise triangles to `out`."],[3,"reverse_clockwising","","Reverses the clockwising of a set of faces."],[3,"split_index_buffer","","Duplicates the indices of each triangle on the given index buffer."],[3,"split_index_buffer_and_recover_topology","","Duplicates the indices of each triangle on the given index buffer, giving the same id to each\nidentical vertex."],[3,"compute_normals","","Computes the normals of a set of vertices."],[0,"path","ncollide_procedural","Path generation."],[1,"PolylinePattern","ncollide_procedural::path","A pattern composed of polyline and two caps."],[1,"PolylinePath","","A path with its sample points given by a polyline."],[1,"ArrowheadCap","","A cap that looks like an arrow."],[1,"NoCap","","A cap that renders nothing."],[2,"PathSample","","A sample point and its associated tangent."],[12,"StartPoint","","A point that starts a new path.",3],[12,"InnerPoint","","A point that is inside of the path currently generated.",3],[12,"EndPoint","","A point that ends the path currently generated.",3],[12,"EndOfSample","","Used when the sampler does not have any other points to generate.",3],[10,"new","","Creates a new `NoCap`.",4],[10,"gen_start_cap","","",4],[10,"gen_end_cap","","",4],[10,"new","","Creates a cap that looks like an arrow.",5],[10,"gen_end_cap","","",5],[10,"gen_start_cap","","",5],[10,"new","","Creates a new polyline pattern.",6],[10,"stroke","","",6],[10,"new","","Creates a new polyline-based path.",7],[10,"next","","",7],[6,"CurveSampler","","A curve sampler."],[9,"next","","Returns the next sample point.",8],[6,"StrokePattern","","A pattern that is replicated along a path."],[9,"stroke","","Generates the mesh using this pattern and the curve sampled by `sampler`.",9],[6,"PolylineCompatibleCap","","Trait to be implemented by caps compatible with a `PolylinePattern`."],[9,"gen_start_cap","","Generates the mesh for the cap at the beginning of a path.",10],[9,"gen_end_cap","","Generates the mesh for the cap at the end of a path.",10],[10,"fmt","ncollide_procedural","",2],[10,"clone","","",2],[10,"unwrap_unified","","Returns the unified index buffer data or fails.",2],[10,"unwrap_split","","Returns the split index buffer data or fails.",2],[10,"fmt","","",0],[10,"clone","","",0],[10,"new","","Creates a new `TriMesh`.",0],[10,"has_normals","","Whether or not this triangle mesh has normals.",0],[10,"has_uvs","","Whether or not this triangle mesh has texture coordinates.",0],[10,"translate_by","","Translates each vertex of this mesh.",0],[10,"transform_by","","Transforms each vertex and rotates each normal of this mesh.",0],[10,"num_triangles","","The number of triangles on this mesh.",0],[10,"rotate_by","","Rotates each vertex and normal of this mesh.",0],[10,"recompute_normals","","Recomputes the mesh normals using its vertex coordinates and adjascency informations\ninfered from the index buffer.",0],[10,"scale_by","","Scales each vertex of this mesh.",0],[10,"scale_by_scalar","","Scales each vertex of this mesh.",0],[10,"unify_index_buffer","","Force the mesh to use the same index for vertices, normals and uvs.",0],[10,"split_index_buffer","","Forces the mesh to use a different index for the vertices, normals and uvs.",0],[10,"clone","","",1],[10,"new","","Creates a new polyline.",1],[10,"translate_by","","Translates each vertex of this polyline.",1],[10,"rotate_by","","Rotates each vertex and normal of this polyline.",1],[10,"transform_by","","Transforms each vertex and rotates each normal of this polyline.",1],[10,"scale_by_scalar","","Scales each vertex of this polyline.",1],[10,"scale_by","","Scales each vertex of this mesh.",1],[4,"TriMesh3","","A 3D triangle mesh."],[4,"Polyline3","","A 3D polyline."],[4,"TriMesh2","","A 2D triangle mesh."],[4,"Polyline2","","A 2D polyline."]],"paths":[[1,"TriMesh"],[1,"Polyline"],[2,"IndexBuffer"],[2,"PathSample"],[1,"NoCap"],[1,"ArrowheadCap"],[1,"PolylinePattern"],[1,"PolylinePath"],[6,"CurveSampler"],[6,"StrokePattern"],[6,"PolylineCompatibleCap"]]};

searchIndex['ncollide_utils'] = {"items":[[0,"","ncollide_utils","Miscelaneous, unsorted generic geometric utilities."],[1,"BacktrackingLineSearch","","The backtracking line search method."],[1,"HashablePartialEq","","A structure that implements `Eq` and is hashable even if the wrapped data implements only\n`PartialEq`."],[3,"center","","Computes the center of a set of point."],[3,"project_homogeneous","","Project n-d point to a (n-1)-d space, dividing each vector by its `w` component."],[3,"project_homogeneous_to","","Project n-d point to a (n-1)-d space, dividing each vector by its `w` component."],[3,"circumcircle","","Computes the circumcircle of a triangle."],[3,"is_affinely_dependent_triangle3","","Tests if three 3D points are exactly aligned without the need of the `Cross` trait."],[3,"is_affinely_dependent_triangle","","Tests if three points are exactly aligned."],[3,"is_point_in_triangle","","Tests if a point is inside of a triangle."],[3,"triangle_area","","Computes the area of a triangle."],[3,"triangle_perimeter","","Computes the perimeter of a triangle."],[3,"tetrahedron_volume","","Computes the volume of a tetrahedron."],[3,"tetrahedron_signed_volume","","Computes the signed volume of a tetrahedron."],[3,"tetrahedron_center","","Computes the center of a tetrahedron."],[3,"remove_unused_points","","Given an index buffer, remove from `points` every point that is not indexed."],[3,"dcos","","Computes the n-th derivative of the cosinus function."],[3,"dsin","","Computes the n-th derivative of the sinus function."],[3,"binom","","Computes the binomial coefficient C^k_n (\"k among n\")."],[3,"maximize_with_newton","","Maximizes a real function using the Newton method."],[3,"newton","","Finds the root of a function using the Newton method."],[3,"minimize_with_bfgs","","Minimizes a function using the bfgs method."],[3,"bfgs","","Minimizes a function using the quasi-newton BFGS method."],[3,"cov","","Computes the convariance matrix of a set of points."],[3,"cov_and_center","","Computes the covariance matrix and center of a set of points."],[3,"center_reduce","","Centers and reduces a set of data."],[3,"sort3","","Sorts a set of three values in increasing order."],[3,"cross3","","A 3d cross product that do not require the `Cross<Self, Self>` trait impl."],[0,"data","","Data structure utilities."],[0,"pair","ncollide_utils::data","Hashable pair of objects implementing `HasUid`."],[1,"Pair","ncollide_utils::data::pair","An unordered pair of elements implementing `HasUid`."],[11,"first","","first object of the pair",0],[11,"second","","second object of the pair",0],[1,"PairTWHash","","Tomas Wang based hash function for a `Pair` object."],[10,"decode","","",0],[10,"encode","","",0],[10,"clone","","",0],[10,"new","","Builds a new `Pair`.",0],[10,"eq","","",0],[10,"decode","","",1],[10,"encode","","",1],[10,"new","","Creates a new PairTWHash",1],[10,"hash","","",1],[0,"hash","ncollide_utils::data","Trait for hash functions."],[1,"UintPairTWHash","ncollide_utils::data::hash","Hash function for pairs of `usize`, using the Tomas Wang hash."],[1,"UintTWHash","","Hash function for `usize`."],[3,"key_from_pair","","Combines two `usize` on a single one."],[3,"tomas_wang_hash","","Tomas Wang integer hash function."],[6,"HashFun","","Hash function."],[9,"hash","","Hash function.",2],[10,"decode","","",3],[10,"encode","","",3],[10,"clone","","",3],[10,"new","","Creates a new UintPairTWHash.",3],[10,"hash","","",3],[10,"decode","","",4],[10,"encode","","",4],[10,"clone","","",4],[10,"new","","Creates a new UintTWHash.",4],[10,"hash","","",4],[0,"hash_map","ncollide_utils::data","An hash map with a customizable hash function."],[1,"Entry","ncollide_utils::data::hash_map","Entry of an `HashMap`."],[11,"key","","The key of the entry.",5],[11,"value","","The value of the entry.",5],[1,"HashMap","","Alternative implementation of `HashMap`."],[10,"decode","","",5],[10,"encode","","",5],[10,"clone","","",5],[10,"decode","","",6],[10,"encode","","",6],[10,"clone","","",6],[10,"new","","Creates a new hash map.",6],[10,"new_with_capacity","","Creates a new hash map with a given capacity.",6],[10,"elements","","The elements added to this hash map.",6],[10,"elements_mut","","The elements added to this hash map.",6],[10,"len","","The number of elements contained by this hashmap.",6],[10,"is_empty","","Whether or not this hashmap is empty.",6],[10,"clear","","Removes everything from this hashmap.",6],[10,"remove_elem_at","","Removes the element at the specified position of the element array.",6],[10,"get_and_remove","","Removes an element and returns its value if it existed.",6],[10,"find_or_insert_lazy","","Same as `self.insert_or_replace(key, value, false)` but with `value` a function which is\ncalled iff. the value does not exist yet. If the functions returns `None`, nothing is\ninserted.",6],[10,"insert_or_replace","","Inserts or replace an element.",6],[10,"contains_key","","Checks whether this hashmap contains a specific key.",6],[10,"find","","Finds a reference to the element with a given key.",6],[10,"insert","","Inserts an element on the hash map.",6],[10,"remove","","Remove an element from the hash map.",6],[10,"find_mut","","Gets a mutable reference to an element of the hashmap.",6],[0,"owned_allocation_cache","ncollide_utils::data","Allocation cache for owned objects."],[1,"OwnedAllocationCache","ncollide_utils::data::owned_allocation_cache","Cache for owned objects."],[10,"new","","Initializes the cache.",7],[10,"alloc","","Box a value into a potentially already allocated box.",7],[10,"retain","","Retains a box which can be re-used by the `box` method.",7],[10,"clear","","Clears the cache, destroying any stored pointer.",7],[0,"vec_slice","ncollide_utils::data","Slicing on non-contiguous data."],[1,"VecSlice","ncollide_utils::data::vec_slice","A vector slice with a specific length and stride."],[1,"VecSliceMut","","A mutable vector slice with a specific length and stride."],[10,"new","","Creates a new immutable slice.",8],[10,"new_unsafe","","Creates a new immutable slice. The size of the data buffer is not checked.",8],[10,"len","","The length of this slice.",8],[10,"is_empty","","Whether or not this slice is empty.",8],[10,"get","","Gets the i-th element of the slice.",8],[10,"get_unchecked","","Gets the i-th element of the slice without bound-checking.",8],[10,"new","","Creates a new mutable slice.",9],[10,"new_unsafe","","Creates a new mutable slice. The size of the data buffer is not checked.",9],[10,"len","","The length of this slice.",9],[10,"is_empty","","Whether or not this slice is empty.",9],[10,"as_slice","","Creates an immutable slice from this mutable slice.",9],[10,"get","","Gets the i-th element of the slice.",9],[10,"get_mut","","Gets a mutable reference to the i-th element of the slice without bound-checking.",9],[10,"get_unchecked","","Gets the i-th element of the slice without bound-checking.",9],[10,"get_unchecked_mut","","Gets a mutable reference to the i-th element of the slice without bound-checking.",9],[10,"copy_from","","Copy the content of another slice.\nBoth slices must have the same length.",9],[0,"ref_with_cost","ncollide_utils::data","A reference packed with a cost value."],[1,"RefWithCost","ncollide_utils::data::ref_with_cost","A reference packed with a cost value."],[11,"object","","The reference to an object.",10],[11,"cost","","The cost of the object.",10],[10,"new","","Creates a new reference packed with a cost value.",10],[10,"eq","","",10],[10,"partial_cmp","","",10],[10,"cmp","","",10],[0,"uid_remap","ncollide_utils::data","A map allowing a slow lookup for arbitrary `usize` and fast lookup for small ones."],[1,"FastKey","ncollide_utils::data::uid_remap","A special type of key used by `UidRemap` to perform faster lookups than with the user-defined\nid of type `usize`."],[1,"UidRemap","","A set of values having large usize key."],[10,"decode","","",11],[10,"encode","","",11],[10,"cmp","","",11],[10,"partial_cmp","","",11],[10,"lt","","",11],[10,"le","","",11],[10,"gt","","",11],[10,"ge","","",11],[10,"eq","","",11],[10,"ne","","",11],[10,"hash","","",11],[10,"clone","","",11],[10,"fmt","","",11],[10,"new_invalid","","Creates a new invalid key that won't be used by the `UidRemap` structure, ever.",11],[10,"uid","","The small uid contained by this key.",11],[10,"decode","","",12],[10,"encode","","",12],[10,"clone","","",12],[10,"fmt","","",12],[10,"default","","",12],[10,"new","","Creates an empty `UidRemap`.",12],[10,"get_fast_key","","Gets the fast key associated to the given key.",12],[10,"len","","Return the number of elements in the map.",12],[10,"is_empty","","Return true if the map contains no elements.",12],[10,"clear","","Clears the map, removing all key-value pairs.",12],[10,"get","","Returns a reference to the value corresponding to the key.",12],[10,"get_fast","","Returns a reference to the value corresponding to the fast key.",12],[10,"contains_key","","Returns true if the map contains a value for the specified key.",12],[10,"contains_fast_key","","Returns true if the map contains a value for the specified fast key.",12],[10,"get_mut","","Returns a mutable reference to the value corresponding to the key.",12],[10,"get_fast_mut","","Returns a mutable reference to the value corresponding to the fast key.",12],[10,"insert","","Inserts a key-value pair to the map. If the key already had a value\npresent in the map, that value and its fast key are returned. Otherwise, `None` is\nreturned.",12],[10,"remove","","Removes a key from the map, returning the value at the key if the key exists.",12],[10,"keys","","Returns an iterator visiting all keys.",12],[10,"values","","Returns an iterator visiting all values.\nThe iterator's element type is `&'r O`.",12],[10,"iter","","Returns an iterator visiting all key-value pairs.",12],[10,"iter_mut","","Returns an iterator visiting all key-value pairs with mutable references to the values.",12],[10,"update","","Updates a value in the map. If the key already exists in the map,\nmodifies the value with `ff` taking `oldval, newval`.\nOtherwise, sets the value to `newval`.\nReturns `true` if the key did not already exist in the map.",12],[10,"update_with_key","","Updates a value in the map. If the key already exists in the map,\nmodifies the value with `ff` taking `key, oldval, newval`.\nOtherwise, sets the value to `newval`.\nReturns `true` if the key did not already exist in the map.",12],[10,"from_iter","","",12],[10,"extend","","",12],[4,"Output","",""],[10,"index","","",12],[10,"new","ncollide_utils","Creates a new backtracking line search methods.",13],[10,"step_size","","",13],[10,"fmt","","",14],[10,"rand","","",14],[10,"clone","","",14],[10,"decode","","",14],[10,"encode","","",14],[10,"eq","","",14],[10,"ne","","",14],[10,"new","","Creates a new `HashablePartialEq`. This is unsafe because you must be sure that you really\nwant to transform the wrapped object's partial equality to an equivalence relation.",14],[10,"unwrap","","Gets the wrapped value.",14],[10,"hash","","",14],[6,"LineSearch","","Trait for line search methods."],[9,"step_size","","Gets a near-optimal step size for the next descent.",15],[6,"AnyPrivate","",""],[9,"get_dyn_type_id","","The type id of `Self`.",16],[6,"AsBytes","","Trait that transforms thing to a slice of u8."],[9,"as_bytes","","",17]],"paths":[[1,"Pair"],[1,"PairTWHash"],[6,"HashFun"],[1,"UintPairTWHash"],[1,"UintTWHash"],[1,"Entry"],[1,"HashMap"],[1,"OwnedAllocationCache"],[1,"VecSlice"],[1,"VecSliceMut"],[1,"RefWithCost"],[1,"FastKey"],[1,"UidRemap"],[1,"BacktrackingLineSearch"],[1,"HashablePartialEq"],[6,"LineSearch"],[6,"AnyPrivate"],[6,"AsBytes"]]};

searchIndex['ncollide_math'] = {"items":[[0,"","ncollide_math","Trait implemented by the types used by ncollide."],[6,"Scalar","","Trait implemented by scalar types."],[6,"Point","","Trait implemented by point types."],[6,"Vect","","Trait implemented by vector types."],[6,"Isometry","","Trait implemented by transformation matrices types."],[6,"HasInertiaMatrix","","Trait implement by vectors that are transformable by the inertia matrix `I`."]],"paths":[]};

searchIndex['nalgebra'] = {"items":[[0,"","nalgebra","# nalgebra"],[1,"Identity","","Special identity matrix. All its operation are no-ops."],[1,"DMat","","Matrix with dimensions unknown at compile-time."],[1,"DVec","","Heap allocated, dynamically sized vector."],[11,"at","","Components of the vector. Contains as much elements as the vector dimension.",0],[1,"DVec1","","Stack-allocated, dynamically sized vector with a maximum size of 1."],[1,"DVec2","","Stack-allocated, dynamically sized vector with a maximum size of 2."],[1,"DVec3","","Stack-allocated, dynamically sized vector with a maximum size of 3."],[1,"DVec4","","Stack-allocated, dynamically sized vector with a maximum size of 4."],[1,"DVec5","","Stack-allocated, dynamically sized vector with a maximum size of 5."],[1,"DVec6","","Stack-allocated, dynamically sized vector with a maximum size of 6."],[1,"Iso2","","Two dimensional isometry."],[11,"rotation","","The rotation applicable by this isometry.",1],[11,"translation","","The translation applicable by this isometry.",1],[1,"Iso3","","Three dimensional isometry."],[11,"rotation","","The rotation applicable by this isometry.",2],[11,"translation","","The translation applicable by this isometry.",2],[1,"Iso4","","Four dimensional isometry."],[11,"rotation","","The rotation applicable by this isometry.",3],[11,"translation","","The translation applicable by this isometry.",3],[1,"Mat1","","Square matrix of dimension 1."],[11,"m11","","",4],[1,"Mat2","","Square matrix of dimension 2."],[11,"m11","","",5],[11,"m21","","",5],[11,"m12","","",5],[11,"m22","","",5],[1,"Mat3","","Square matrix of dimension 3."],[11,"m11","","",6],[11,"m21","","",6],[11,"m31","","",6],[11,"m12","","",6],[11,"m22","","",6],[11,"m32","","",6],[11,"m13","","",6],[11,"m23","","",6],[11,"m33","","",6],[1,"Mat4","","Square matrix of dimension 4."],[11,"m11","","",7],[11,"m21","","",7],[11,"m31","","",7],[11,"m41","","",7],[11,"m12","","",7],[11,"m22","","",7],[11,"m32","","",7],[11,"m42","","",7],[11,"m13","","",7],[11,"m23","","",7],[11,"m33","","",7],[11,"m43","","",7],[11,"m14","","",7],[11,"m24","","",7],[11,"m34","","",7],[11,"m44","","",7],[1,"Mat5","","Square matrix of dimension 5."],[11,"m11","","",8],[11,"m21","","",8],[11,"m31","","",8],[11,"m41","","",8],[11,"m51","","",8],[11,"m12","","",8],[11,"m22","","",8],[11,"m32","","",8],[11,"m42","","",8],[11,"m52","","",8],[11,"m13","","",8],[11,"m23","","",8],[11,"m33","","",8],[11,"m43","","",8],[11,"m53","","",8],[11,"m14","","",8],[11,"m24","","",8],[11,"m34","","",8],[11,"m44","","",8],[11,"m54","","",8],[11,"m15","","",8],[11,"m25","","",8],[11,"m35","","",8],[11,"m45","","",8],[11,"m55","","",8],[1,"Mat6","","Square matrix of dimension 6."],[11,"m11","","",9],[11,"m21","","",9],[11,"m31","","",9],[11,"m41","","",9],[11,"m51","","",9],[11,"m61","","",9],[11,"m12","","",9],[11,"m22","","",9],[11,"m32","","",9],[11,"m42","","",9],[11,"m52","","",9],[11,"m62","","",9],[11,"m13","","",9],[11,"m23","","",9],[11,"m33","","",9],[11,"m43","","",9],[11,"m53","","",9],[11,"m63","","",9],[11,"m14","","",9],[11,"m24","","",9],[11,"m34","","",9],[11,"m44","","",9],[11,"m54","","",9],[11,"m64","","",9],[11,"m15","","",9],[11,"m25","","",9],[11,"m35","","",9],[11,"m45","","",9],[11,"m55","","",9],[11,"m65","","",9],[11,"m16","","",9],[11,"m26","","",9],[11,"m36","","",9],[11,"m46","","",9],[11,"m56","","",9],[11,"m66","","",9],[1,"Rot2","","Two dimensional rotation matrix."],[1,"Rot3","","Three dimensional rotation matrix."],[1,"Rot4","","Four dimensional rotation matrix."],[1,"Vec0","","Vector of dimension 0."],[1,"Vec1","","Vector of dimension 1."],[11,"x","","First component of the vector.",10],[1,"Vec2","","Vector of dimension 2."],[11,"x","","First component of the vector.",11],[11,"y","","Second component of the vector.",11],[1,"Vec3","","Vector of dimension 3."],[11,"x","","First component of the vector.",12],[11,"y","","Second component of the vector.",12],[11,"z","","Third component of the vector.",12],[1,"Vec4","","Vector of dimension 4."],[11,"x","","First component of the vector.",13],[11,"y","","Second component of the vector.",13],[11,"z","","Third component of the vector.",13],[11,"w","","Fourth component of the vector.",13],[1,"Vec5","","Vector of dimension 5."],[11,"x","","First component of the vector.",14],[11,"y","","Second component of the vector.",14],[11,"z","","Third component of the vector.",14],[11,"w","","Fourth component of the vector.",14],[11,"a","","Fifth of the vector.",14],[1,"Vec6","","Vector of dimension 6."],[11,"x","","First component of the vector.",15],[11,"y","","Second component of the vector.",15],[11,"z","","Third component of the vector.",15],[11,"w","","Fourth component of the vector.",15],[11,"a","","Fifth of the vector.",15],[11,"b","","Sixth component of the vector.",15],[1,"Pnt0","","Point of dimension 0."],[1,"Pnt1","","Point of dimension 1."],[11,"x","","First component of the point.",16],[1,"Pnt2","","Point of dimension 2."],[11,"x","","First component of the point.",17],[11,"y","","Second component of the point.",17],[1,"Pnt3","","Point of dimension 3."],[11,"x","","First component of the point.",18],[11,"y","","Second component of the point.",18],[11,"z","","Third component of the point.",18],[1,"Pnt4","","Point of dimension 4."],[11,"x","","First component of the point.",19],[11,"y","","Second component of the point.",19],[11,"z","","Third component of the point.",19],[11,"w","","Fourth component of the point.",19],[1,"Pnt5","","Point of dimension 5."],[11,"x","","First component of the point.",20],[11,"y","","Second component of the point.",20],[11,"z","","Third component of the point.",20],[11,"w","","Fourth component of the point.",20],[11,"a","","Fifth of the point.",20],[1,"Pnt6","","Point of dimension 6."],[11,"x","","First component of the point.",21],[11,"y","","Second component of the point.",21],[11,"z","","Third component of the point.",21],[11,"w","","Fourth component of the point.",21],[11,"a","","Fifth of the point.",21],[11,"b","","Sixth component of the point.",21],[1,"Persp3","","A 3D perspective projection stored without any matrix."],[1,"PerspMat3","","A 3D perspective projection stored as a 4D matrix."],[1,"Ortho3","","A 3D orthographic projection stored without any matrix."],[1,"OrthoMat3","","A 3D orthographic projection stored as a 4D matrix."],[1,"Quat","","A quaternion."],[11,"w","","The scalar component of the quaternion.",22],[11,"i","","The first vector component of the quaternion.",22],[11,"j","","The second vector component of the quaternion.",22],[11,"k","","The third vector component of the quaternion.",22],[1,"UnitQuat","","A unit quaternion that can represent a 3D rotation."],[2,"POrdering","","Result of a partial ordering."],[12,"PartialLess","","Result of a strict comparison.",23],[12,"PartialEqual","","Equality relationship.",23],[12,"PartialGreater","","Result of a strict comparison.",23],[12,"NotComparable","","Result of a comparison between two objects that are not comparable.",23],[3,"qr","","QR decomposition using Householder reflections."],[3,"householder_matrix","","Get the householder matrix corresponding to a reflexion to the hyperplane\ndefined by `vec`. It can be a reflexion contained in a subspace."],[3,"clamp","","Change the input value to ensure it is on the range `[min, max]`."],[3,"max","","Same as `cmp::max`."],[3,"min","","Same as `cmp::min`."],[3,"inf","","Returns the infimum of `a` and `b`."],[3,"sup","","Returns the supremum of `a` and `b`."],[3,"partial_cmp","","Compare `a` and `b` using a partial ordering relation."],[3,"partial_lt","","Returns `true` iff `a` and `b` are comparable and `a < b`."],[3,"partial_le","","Returns `true` iff `a` and `b` are comparable and `a <= b`."],[3,"partial_gt","","Returns `true` iff `a` and `b` are comparable and `a > b`."],[3,"partial_ge","","Returns `true` iff `a` and `b` are comparable and `a >= b`."],[3,"partial_min","","Return the minimum of `a` and `b` if they are comparable."],[3,"partial_max","","Return the maximum of `a` and `b` if they are comparable."],[3,"partial_clamp","","Clamp `value` between `min` and `max`. Returns `None` if `value` is not comparable to\n`min` or `max`."],[3,"identity","","Create a special identity object."],[3,"zero","","Create a zero-valued value."],[3,"is_zero","","Tests is a value is iqual to zero."],[3,"one","","Create a one-valued value."],[3,"orig","","Returns the trivial origin of an affine space."],[3,"center","","Returns the center of two points."],[3,"dist","","Returns the distance between two points."],[3,"sqdist","","Returns the squared distance between two points."],[3,"perspective3d","","Computes a projection matrix given the frustrum near plane width, height, the field of\nview, and the distance to the clipping planes (`znear` and `zfar`)."],[3,"translation","","Gets the translation applicable by `m`."],[3,"inv_translation","","Gets the inverse translation applicable by `m`."],[3,"append_translation","","Applies the translation `v` to a copy of `m`."],[3,"translate","","Applies a translation to a point."],[3,"inv_translate","","Applies an inverse translation to a point."],[3,"rotation","","Gets the rotation applicable by `m`."],[3,"inv_rotation","","Gets the inverse rotation applicable by `m`."],[3,"append_rotation","","Applies the rotation `v` to a copy of `m`."],[3,"prepend_rotation","","Pre-applies the rotation `v` to a copy of `m`."],[3,"rotate","","Applies a rotation to a vector."],[3,"inv_rotate","","Applies an inverse rotation to a vector."],[3,"append_rotation_wrt_point","","Rotates a copy of `m` by `amount` using `center` as the pivot point."],[3,"append_rotation_wrt_center","","Rotates a copy of `m` by `amount` using `m.translation()` as the pivot point."],[3,"to_rot_mat","","Builds a rotation matrix from `r`."],[3,"absolute_rotate","","Applies a rotation using the absolute values of its components."],[3,"transformation","","Gets the transformation applicable by `m`."],[3,"inv_transformation","","Gets the inverse transformation applicable by `m`."],[3,"append_transformation","","Gets a transformed copy of `m`."],[3,"transform","","Applies a transformation to a vector."],[3,"inv_transform","","Applies an inverse transformation to a vector."],[3,"dot","","Computes the dot product of two vectors."],[3,"norm","","Computes the L2 norm of a vector."],[3,"sqnorm","","Computes the squared L2 norm of a vector."],[3,"normalize","","Gets the normalized version of a vector."],[3,"det","","Computes the determinant of a square matrix."],[3,"cross","","Computes the cross product of two vectors."],[3,"cross_matrix","","Given a vector, computes the matrix which, when multiplied by another vector, computes a cross\nproduct."],[3,"to_homogeneous","","Converts a matrix or vector to homogeneous coordinates."],[3,"from_homogeneous","","Converts a matrix or vector from homogeneous coordinates."],[3,"sample_sphere","","Samples the unit sphere living on the dimension as the samples types."],[3,"approx_eq","","Tests approximate equality."],[3,"approx_eq_eps","","Tests approximate equality using a custom epsilon."],[3,"abs","","Computes a component-wise absolute value."],[3,"inv","","Gets an inverted copy of a matrix."],[3,"transpose","","Gets a transposed copy of a matrix."],[3,"outer","","Computes the outer product of two vectors."],[3,"cov","","Computes the covariance of a set of observations."],[3,"mean","","Computes the mean of a set of observations."],[3,"eigen_qr","","Computes the eigenvalues and eigenvectors of a square matrix usin the QR algorithm."],[3,"new_identity","","Construct the identity matrix for a given dimension"],[3,"canonical_basis","","Computes the canonical basis for a given dimension."],[3,"orthonormal_subspace_basis","","Computes the basis of the orthonormal subspace of a given vector."],[3,"canonical_basis_element","","Gets the (0-based) i-th element of the canonical basis of V."],[3,"diag","","Gets the diagonal of a square matrix."],[3,"dim","","Gets the dimension an object lives in."],[3,"shape","","Gets the indexable range of an object."],[3,"cast","","Converts an object from one type to another."],[10,"clone","","",24],[10,"eq","","",24],[10,"ne","","",24],[10,"new_uninitialized","","Creates an uninitialized matrix.",24],[10,"new_zeros","","Builds a matrix filled with zeros.",24],[10,"is_zero","","Tests if all components of the matrix are zeroes.",24],[10,"reset","","",24],[10,"new_random","","Builds a matrix filled with random values.",24],[10,"new_ones","","Builds a matrix filled with a given constant.",24],[10,"from_elem","","Builds a matrix filled with a given constant.",24],[10,"from_row_vec","","Builds a matrix filled with the components provided by a vector.\nThe vector contains the matrix data in row-major order.\nNote that `from_col_vec` is a lot faster than `from_row_vec` since a `DMat` stores its data\nin column-major order.",24],[10,"from_col_vec","","Builds a matrix filled with the components provided by a vector.\nThe vector contains the matrix data in column-major order.\nNote that `from_col_vec` is a lot faster than `from_row_vec` since a `DMat` stores its data\nin column-major order.",24],[10,"from_fn","","Builds a matrix filled with a given constant.",24],[10,"nrows","","The number of row on the matrix.",24],[10,"ncols","","The number of columns on the matrix.",24],[10,"to_vec","","Transforms this matrix isizeo an array. This consumes the matrix and is O(1).\nThe returned vector contains the matrix data in column-major order.",24],[10,"as_vec","","Gets a reference to this matrix data.\nThe returned vector contains the matrix data in column-major order.",24],[10,"as_mut_vec","","Gets a mutable reference to this matrix data.\nThe returned vector contains the matrix data in column-major order.",24],[10,"new_identity","","Builds an identity matrix.",24],[10,"set","","Changes the value of a component of the matrix.",24],[10,"unsafe_set","","Just like `set` without bounds checking.",24],[10,"at","","Reads the value of a component of the matrix.",24],[10,"unsafe_at","","Just like `at` without bounds checking.",24],[10,"swap","","",24],[10,"shape","","",24],[10,"index","","",24],[10,"index_mut","","",24],[10,"mul","","",24],[10,"mul","","",24],[10,"mul","","",0],[10,"inv_cpy","","",24],[10,"inv","","",24],[10,"transpose_cpy","","",24],[10,"transpose","","",24],[10,"mean","","",24],[10,"cov","","",24],[10,"col_slice","","",24],[10,"row_slice","","",24],[10,"from_diag","","",24],[10,"set_diag","","",24],[10,"diag","","",24],[10,"approx_epsilon","","",24],[10,"approx_ulps","","",24],[10,"approx_eq_eps","","",24],[10,"approx_eq_ulps","","",24],[10,"fmt","","",24],[10,"mul","","",24],[10,"div","","",24],[10,"add","","",24],[10,"sub","","",24],[10,"clone","","",0],[10,"fmt","","",0],[10,"eq","","",0],[10,"ne","","",0],[10,"new_uninitialized","","Creates an uninitialized vec.",0],[10,"from_elem","","Builds a vector filled with a constant.",0],[10,"from_slice","","Builds a vector filled with the components provided by a vector.",0],[10,"from_fn","","Builds a vector filled with the result of a function.",0],[10,"len","","",0],[10,"from_iter","","",0],[10,"new_zeros","","Builds a vector filled with zeros.",0],[10,"is_zero","","Tests if all components of the vector are zeroes.",0],[10,"as_slice","","Slices this vector.",0],[10,"as_mut_slice","","Mutably slices this vector.",0],[10,"shape","","",0],[10,"at","","",0],[10,"set","","",0],[10,"swap","","",0],[10,"unsafe_at","","",0],[10,"unsafe_set","","",0],[10,"index","","",0],[10,"index_mut","","",0],[10,"new_ones","","Builds a vector filled with ones.",0],[10,"new_random","","Builds a vector filled with random values.",0],[10,"iter","","",0],[10,"iter_mut","","",0],[10,"axpy","","",0],[10,"canonical_basis_with_dim","","Computes the canonical basis for the given dimension. A canonical basis is a set of\nvectors, mutually orthogonal, with all its component equal to 0.0 except one which is equal\nto 1.0.",0],[10,"orthogonal_subspace_basis","","Computes a basis of the space orthogonal to the vector. If the input vector is of dimension\n`n`, this will return `n - 1` vectors.",0],[10,"mul","","",0],[10,"div","","",0],[10,"add","","",0],[10,"sub","","",0],[10,"neg","","",0],[10,"dot","","",0],[10,"sqnorm","","",0],[10,"normalize_cpy","","",0],[10,"normalize","","",0],[10,"approx_epsilon","","",0],[10,"approx_ulps","","",0],[10,"approx_eq_eps","","",0],[10,"approx_eq_ulps","","",0],[10,"mul","","",0],[10,"div","","",0],[10,"add","","",0],[10,"sub","","",0],[10,"len","","",25],[10,"eq","","",25],[10,"clone","","",25],[10,"new_zeros","","Builds a vector filled with zeros.",25],[10,"is_zero","","Tests if all components of the vector are zeroes.",25],[10,"as_slice","","Slices this vector.",25],[10,"as_mut_slice","","Mutably slices this vector.",25],[10,"shape","","",25],[10,"at","","",25],[10,"set","","",25],[10,"swap","","",25],[10,"unsafe_at","","",25],[10,"unsafe_set","","",25],[10,"index","","",25],[10,"index_mut","","",25],[10,"new_ones","","Builds a vector filled with ones.",25],[10,"new_random","","Builds a vector filled with random values.",25],[10,"iter","","",25],[10,"iter_mut","","",25],[10,"axpy","","",25],[10,"canonical_basis_with_dim","","Computes the canonical basis for the given dimension. A canonical basis is a set of\nvectors, mutually orthogonal, with all its component equal to 0.0 except one which is equal\nto 1.0.",25],[10,"orthogonal_subspace_basis","","Computes a basis of the space orthogonal to the vector. If the input vector is of dimension\n`n`, this will return `n - 1` vectors.",25],[10,"mul","","",25],[10,"div","","",25],[10,"add","","",25],[10,"sub","","",25],[10,"neg","","",25],[10,"dot","","",25],[10,"sqnorm","","",25],[10,"normalize_cpy","","",25],[10,"normalize","","",25],[10,"approx_epsilon","","",25],[10,"approx_ulps","","",25],[10,"approx_eq_eps","","",25],[10,"approx_eq_ulps","","",25],[10,"mul","","",25],[10,"div","","",25],[10,"add","","",25],[10,"sub","","",25],[10,"from_elem","","Builds a vector filled with a constant.",25],[10,"from_slice","","Builds a vector filled with the components provided by a vector.",25],[10,"from_fn","","Builds a vector filled with the result of a function.",25],[10,"from_iter","","",25],[10,"len","","",26],[10,"eq","","",26],[10,"clone","","",26],[10,"new_zeros","","Builds a vector filled with zeros.",26],[10,"is_zero","","Tests if all components of the vector are zeroes.",26],[10,"as_slice","","Slices this vector.",26],[10,"as_mut_slice","","Mutably slices this vector.",26],[10,"shape","","",26],[10,"at","","",26],[10,"set","","",26],[10,"swap","","",26],[10,"unsafe_at","","",26],[10,"unsafe_set","","",26],[10,"index","","",26],[10,"index_mut","","",26],[10,"new_ones","","Builds a vector filled with ones.",26],[10,"new_random","","Builds a vector filled with random values.",26],[10,"iter","","",26],[10,"iter_mut","","",26],[10,"axpy","","",26],[10,"canonical_basis_with_dim","","Computes the canonical basis for the given dimension. A canonical basis is a set of\nvectors, mutually orthogonal, with all its component equal to 0.0 except one which is equal\nto 1.0.",26],[10,"orthogonal_subspace_basis","","Computes a basis of the space orthogonal to the vector. If the input vector is of dimension\n`n`, this will return `n - 1` vectors.",26],[10,"mul","","",26],[10,"div","","",26],[10,"add","","",26],[10,"sub","","",26],[10,"neg","","",26],[10,"dot","","",26],[10,"sqnorm","","",26],[10,"normalize_cpy","","",26],[10,"normalize","","",26],[10,"approx_epsilon","","",26],[10,"approx_ulps","","",26],[10,"approx_eq_eps","","",26],[10,"approx_eq_ulps","","",26],[10,"mul","","",26],[10,"div","","",26],[10,"add","","",26],[10,"sub","","",26],[10,"from_elem","","Builds a vector filled with a constant.",26],[10,"from_slice","","Builds a vector filled with the components provided by a vector.",26],[10,"from_fn","","Builds a vector filled with the result of a function.",26],[10,"from_iter","","",26],[10,"len","","",27],[10,"eq","","",27],[10,"clone","","",27],[10,"new_zeros","","Builds a vector filled with zeros.",27],[10,"is_zero","","Tests if all components of the vector are zeroes.",27],[10,"as_slice","","Slices this vector.",27],[10,"as_mut_slice","","Mutably slices this vector.",27],[10,"shape","","",27],[10,"at","","",27],[10,"set","","",27],[10,"swap","","",27],[10,"unsafe_at","","",27],[10,"unsafe_set","","",27],[10,"index","","",27],[10,"index_mut","","",27],[10,"new_ones","","Builds a vector filled with ones.",27],[10,"new_random","","Builds a vector filled with random values.",27],[10,"iter","","",27],[10,"iter_mut","","",27],[10,"axpy","","",27],[10,"canonical_basis_with_dim","","Computes the canonical basis for the given dimension. A canonical basis is a set of\nvectors, mutually orthogonal, with all its component equal to 0.0 except one which is equal\nto 1.0.",27],[10,"orthogonal_subspace_basis","","Computes a basis of the space orthogonal to the vector. If the input vector is of dimension\n`n`, this will return `n - 1` vectors.",27],[10,"mul","","",27],[10,"div","","",27],[10,"add","","",27],[10,"sub","","",27],[10,"neg","","",27],[10,"dot","","",27],[10,"sqnorm","","",27],[10,"normalize_cpy","","",27],[10,"normalize","","",27],[10,"approx_epsilon","","",27],[10,"approx_ulps","","",27],[10,"approx_eq_eps","","",27],[10,"approx_eq_ulps","","",27],[10,"mul","","",27],[10,"div","","",27],[10,"add","","",27],[10,"sub","","",27],[10,"from_elem","","Builds a vector filled with a constant.",27],[10,"from_slice","","Builds a vector filled with the components provided by a vector.",27],[10,"from_fn","","Builds a vector filled with the result of a function.",27],[10,"from_iter","","",27],[10,"len","","",28],[10,"eq","","",28],[10,"clone","","",28],[10,"new_zeros","","Builds a vector filled with zeros.",28],[10,"is_zero","","Tests if all components of the vector are zeroes.",28],[10,"as_slice","","Slices this vector.",28],[10,"as_mut_slice","","Mutably slices this vector.",28],[10,"shape","","",28],[10,"at","","",28],[10,"set","","",28],[10,"swap","","",28],[10,"unsafe_at","","",28],[10,"unsafe_set","","",28],[10,"index","","",28],[10,"index_mut","","",28],[10,"new_ones","","Builds a vector filled with ones.",28],[10,"new_random","","Builds a vector filled with random values.",28],[10,"iter","","",28],[10,"iter_mut","","",28],[10,"axpy","","",28],[10,"canonical_basis_with_dim","","Computes the canonical basis for the given dimension. A canonical basis is a set of\nvectors, mutually orthogonal, with all its component equal to 0.0 except one which is equal\nto 1.0.",28],[10,"orthogonal_subspace_basis","","Computes a basis of the space orthogonal to the vector. If the input vector is of dimension\n`n`, this will return `n - 1` vectors.",28],[10,"mul","","",28],[10,"div","","",28],[10,"add","","",28],[10,"sub","","",28],[10,"neg","","",28],[10,"dot","","",28],[10,"sqnorm","","",28],[10,"normalize_cpy","","",28],[10,"normalize","","",28],[10,"approx_epsilon","","",28],[10,"approx_ulps","","",28],[10,"approx_eq_eps","","",28],[10,"approx_eq_ulps","","",28],[10,"mul","","",28],[10,"div","","",28],[10,"add","","",28],[10,"sub","","",28],[10,"from_elem","","Builds a vector filled with a constant.",28],[10,"from_slice","","Builds a vector filled with the components provided by a vector.",28],[10,"from_fn","","Builds a vector filled with the result of a function.",28],[10,"from_iter","","",28],[10,"len","","",29],[10,"eq","","",29],[10,"clone","","",29],[10,"new_zeros","","Builds a vector filled with zeros.",29],[10,"is_zero","","Tests if all components of the vector are zeroes.",29],[10,"as_slice","","Slices this vector.",29],[10,"as_mut_slice","","Mutably slices this vector.",29],[10,"shape","","",29],[10,"at","","",29],[10,"set","","",29],[10,"swap","","",29],[10,"unsafe_at","","",29],[10,"unsafe_set","","",29],[10,"index","","",29],[10,"index_mut","","",29],[10,"new_ones","","Builds a vector filled with ones.",29],[10,"new_random","","Builds a vector filled with random values.",29],[10,"iter","","",29],[10,"iter_mut","","",29],[10,"axpy","","",29],[10,"canonical_basis_with_dim","","Computes the canonical basis for the given dimension. A canonical basis is a set of\nvectors, mutually orthogonal, with all its component equal to 0.0 except one which is equal\nto 1.0.",29],[10,"orthogonal_subspace_basis","","Computes a basis of the space orthogonal to the vector. If the input vector is of dimension\n`n`, this will return `n - 1` vectors.",29],[10,"mul","","",29],[10,"div","","",29],[10,"add","","",29],[10,"sub","","",29],[10,"neg","","",29],[10,"dot","","",29],[10,"sqnorm","","",29],[10,"normalize_cpy","","",29],[10,"normalize","","",29],[10,"approx_epsilon","","",29],[10,"approx_ulps","","",29],[10,"approx_eq_eps","","",29],[10,"approx_eq_ulps","","",29],[10,"mul","","",29],[10,"div","","",29],[10,"add","","",29],[10,"sub","","",29],[10,"from_elem","","Builds a vector filled with a constant.",29],[10,"from_slice","","Builds a vector filled with the components provided by a vector.",29],[10,"from_fn","","Builds a vector filled with the result of a function.",29],[10,"from_iter","","",29],[10,"len","","",30],[10,"eq","","",30],[10,"clone","","",30],[10,"new_zeros","","Builds a vector filled with zeros.",30],[10,"is_zero","","Tests if all components of the vector are zeroes.",30],[10,"as_slice","","Slices this vector.",30],[10,"as_mut_slice","","Mutably slices this vector.",30],[10,"shape","","",30],[10,"at","","",30],[10,"set","","",30],[10,"swap","","",30],[10,"unsafe_at","","",30],[10,"unsafe_set","","",30],[10,"index","","",30],[10,"index_mut","","",30],[10,"new_ones","","Builds a vector filled with ones.",30],[10,"new_random","","Builds a vector filled with random values.",30],[10,"iter","","",30],[10,"iter_mut","","",30],[10,"axpy","","",30],[10,"canonical_basis_with_dim","","Computes the canonical basis for the given dimension. A canonical basis is a set of\nvectors, mutually orthogonal, with all its component equal to 0.0 except one which is equal\nto 1.0.",30],[10,"orthogonal_subspace_basis","","Computes a basis of the space orthogonal to the vector. If the input vector is of dimension\n`n`, this will return `n - 1` vectors.",30],[10,"mul","","",30],[10,"div","","",30],[10,"add","","",30],[10,"sub","","",30],[10,"neg","","",30],[10,"dot","","",30],[10,"sqnorm","","",30],[10,"normalize_cpy","","",30],[10,"normalize","","",30],[10,"approx_epsilon","","",30],[10,"approx_ulps","","",30],[10,"approx_eq_eps","","",30],[10,"approx_eq_ulps","","",30],[10,"mul","","",30],[10,"div","","",30],[10,"add","","",30],[10,"sub","","",30],[10,"from_elem","","Builds a vector filled with a constant.",30],[10,"from_slice","","Builds a vector filled with the components provided by a vector.",30],[10,"from_fn","","Builds a vector filled with the result of a function.",30],[10,"from_iter","","",30],[10,"fmt","","",31],[10,"rand","","",31],[10,"clone","","",31],[10,"decode","","",31],[10,"eq","","",31],[10,"ne","","",31],[10,"new","","Creates a new vector.",31],[10,"new_repeat","","Creates a new vector. The parameter is not taken in account.",31],[10,"fmt","","",10],[10,"rand","","",10],[10,"hash","","",10],[10,"clone","","",10],[10,"decode","","",10],[10,"encode","","",10],[10,"eq","","",10],[10,"ne","","",10],[10,"new","","Creates a new vector.",10],[10,"inf","","",10],[10,"sup","","",10],[10,"partial_cmp","","",10],[10,"partial_lt","","",10],[10,"partial_le","","",10],[10,"partial_gt","","",10],[10,"partial_ge","","",10],[10,"x","","Create a unit vector with its `$compN` component equal to 1.0.",10],[10,"from","","",10],[10,"as_array","","View this vector as an array.",10],[10,"as_array_mut","","View this vector as a mutable array.",10],[10,"from_array_ref","","View an array as a vector.",10],[10,"from_array_mut","","View an array as a vector.",10],[10,"index","","",10],[10,"index_mut","","",10],[10,"shape","","",10],[10,"at","","",10],[10,"set","","",10],[10,"swap","","",10],[10,"unsafe_at","","",10],[10,"unsafe_set","","",10],[10,"at_fast","","Unsafe read access to a vector element by index.",10],[10,"set_fast","","Unsafe write access to a vector element by index.",10],[10,"new_repeat","","Creates a new vector with all its components equal to a given value.",10],[10,"dim","","",10],[10,"len","","",10],[10,"add","","",10],[10,"sub","","",10],[10,"mul","","",10],[10,"div","","",10],[10,"add","","",10],[10,"sub","","",10],[10,"mul","","",10],[10,"div","","",10],[10,"neg","","",10],[10,"dot","","",10],[10,"mul_s","","",10],[10,"div_s","","",10],[10,"add_s","","",10],[10,"sub_s","","",10],[10,"translation","","",10],[10,"inv_translation","","",10],[10,"append_translation","","",10],[10,"append_translation_cpy","","",10],[10,"prepend_translation","","",10],[10,"prepend_translation_cpy","","",10],[10,"set_translation","","",10],[10,"sqnorm","","",10],[10,"normalize_cpy","","",10],[10,"normalize","","",10],[10,"approx_epsilon","","",10],[10,"approx_ulps","","",10],[10,"approx_eq","","",10],[10,"approx_eq_eps","","",10],[10,"approx_eq_ulps","","",10],[10,"one","","",10],[10,"zero","","",10],[10,"is_zero","","",10],[10,"from_iter","","",10],[10,"max_value","","",10],[10,"min_value","","",10],[10,"axpy","","",10],[10,"iter","","",10],[10,"iter_mut","","",10],[10,"to_homogeneous","","",10],[10,"from","","",10],[10,"translate","","",10],[10,"inv_translate","","",10],[10,"rotate","","",10],[10,"inv_rotate","","",10],[10,"rotate","","",16],[10,"inv_rotate","","",16],[10,"transform","","",10],[10,"inv_transform","","",10],[10,"to_pnt","","",10],[10,"as_pnt","","",10],[10,"to_pnt","","",10],[10,"as_pnt","","",10],[10,"abs","","",10],[10,"fmt","","",11],[10,"rand","","",11],[10,"hash","","",11],[10,"clone","","",11],[10,"decode","","",11],[10,"encode","","",11],[10,"eq","","",11],[10,"ne","","",11],[10,"new","","Creates a new vector.",11],[10,"inf","","",11],[10,"sup","","",11],[10,"partial_cmp","","",11],[10,"partial_lt","","",11],[10,"partial_le","","",11],[10,"partial_gt","","",11],[10,"partial_ge","","",11],[10,"x","","Create a unit vector with its `$compN` component equal to 1.0.",11],[10,"y","","Create a unit vector with its `$compN` component equal to 1.0.",11],[10,"from","","",11],[10,"as_array","","View this vector as an array.",11],[10,"as_array_mut","","View this vector as a mutable array.",11],[10,"from_array_ref","","View an array as a vector.",11],[10,"from_array_mut","","View an array as a vector.",11],[10,"index","","",11],[10,"index_mut","","",11],[10,"shape","","",11],[10,"at","","",11],[10,"set","","",11],[10,"swap","","",11],[10,"unsafe_at","","",11],[10,"unsafe_set","","",11],[10,"at_fast","","Unsafe read access to a vector element by index.",11],[10,"set_fast","","Unsafe write access to a vector element by index.",11],[10,"new_repeat","","Creates a new vector with all its components equal to a given value.",11],[10,"dim","","",11],[10,"len","","",11],[10,"add","","",11],[10,"sub","","",11],[10,"mul","","",11],[10,"div","","",11],[10,"add","","",11],[10,"sub","","",11],[10,"mul","","",11],[10,"div","","",11],[10,"neg","","",11],[10,"dot","","",11],[10,"mul_s","","",11],[10,"div_s","","",11],[10,"add_s","","",11],[10,"sub_s","","",11],[10,"translation","","",11],[10,"inv_translation","","",11],[10,"append_translation","","",11],[10,"append_translation_cpy","","",11],[10,"prepend_translation","","",11],[10,"prepend_translation_cpy","","",11],[10,"set_translation","","",11],[10,"sqnorm","","",11],[10,"normalize_cpy","","",11],[10,"normalize","","",11],[10,"approx_epsilon","","",11],[10,"approx_ulps","","",11],[10,"approx_eq","","",11],[10,"approx_eq_eps","","",11],[10,"approx_eq_ulps","","",11],[10,"one","","",11],[10,"zero","","",11],[10,"is_zero","","",11],[10,"from_iter","","",11],[10,"max_value","","",11],[10,"min_value","","",11],[10,"axpy","","",11],[10,"iter","","",11],[10,"iter_mut","","",11],[10,"to_homogeneous","","",11],[10,"from","","",11],[10,"translate","","",11],[10,"inv_translate","","",11],[10,"rotate","","",11],[10,"inv_rotate","","",11],[10,"rotate","","",17],[10,"inv_rotate","","",17],[10,"transform","","",11],[10,"inv_transform","","",11],[10,"to_pnt","","",11],[10,"as_pnt","","",11],[10,"to_pnt","","",11],[10,"as_pnt","","",11],[10,"abs","","",11],[10,"fmt","","",12],[10,"rand","","",12],[10,"hash","","",12],[10,"clone","","",12],[10,"decode","","",12],[10,"encode","","",12],[10,"eq","","",12],[10,"ne","","",12],[10,"new","","Creates a new vector.",12],[10,"inf","","",12],[10,"sup","","",12],[10,"partial_cmp","","",12],[10,"partial_lt","","",12],[10,"partial_le","","",12],[10,"partial_gt","","",12],[10,"partial_ge","","",12],[10,"x","","Create a unit vector with its `$compN` component equal to 1.0.",12],[10,"y","","Create a unit vector with its `$compN` component equal to 1.0.",12],[10,"z","","Create a unit vector with its `$compN` component equal to 1.0.",12],[10,"from","","",12],[10,"as_array","","View this vector as an array.",12],[10,"as_array_mut","","View this vector as a mutable array.",12],[10,"from_array_ref","","View an array as a vector.",12],[10,"from_array_mut","","View an array as a vector.",12],[10,"index","","",12],[10,"index_mut","","",12],[10,"shape","","",12],[10,"at","","",12],[10,"set","","",12],[10,"swap","","",12],[10,"unsafe_at","","",12],[10,"unsafe_set","","",12],[10,"at_fast","","Unsafe read access to a vector element by index.",12],[10,"set_fast","","Unsafe write access to a vector element by index.",12],[10,"new_repeat","","Creates a new vector with all its components equal to a given value.",12],[10,"dim","","",12],[10,"len","","",12],[10,"add","","",12],[10,"sub","","",12],[10,"mul","","",12],[10,"div","","",12],[10,"add","","",12],[10,"sub","","",12],[10,"mul","","",12],[10,"div","","",12],[10,"neg","","",12],[10,"dot","","",12],[10,"mul_s","","",12],[10,"div_s","","",12],[10,"add_s","","",12],[10,"sub_s","","",12],[10,"translation","","",12],[10,"inv_translation","","",12],[10,"append_translation","","",12],[10,"append_translation_cpy","","",12],[10,"prepend_translation","","",12],[10,"prepend_translation_cpy","","",12],[10,"set_translation","","",12],[10,"sqnorm","","",12],[10,"normalize_cpy","","",12],[10,"normalize","","",12],[10,"approx_epsilon","","",12],[10,"approx_ulps","","",12],[10,"approx_eq","","",12],[10,"approx_eq_eps","","",12],[10,"approx_eq_ulps","","",12],[10,"one","","",12],[10,"zero","","",12],[10,"is_zero","","",12],[10,"from_iter","","",12],[10,"max_value","","",12],[10,"min_value","","",12],[10,"axpy","","",12],[10,"iter","","",12],[10,"iter_mut","","",12],[10,"to_homogeneous","","",12],[10,"from","","",12],[10,"translate","","",12],[10,"inv_translate","","",12],[10,"rotate","","",12],[10,"inv_rotate","","",12],[10,"rotate","","",18],[10,"inv_rotate","","",18],[10,"transform","","",12],[10,"inv_transform","","",12],[10,"to_pnt","","",12],[10,"as_pnt","","",12],[10,"to_pnt","","",12],[10,"as_pnt","","",12],[10,"abs","","",12],[10,"fmt","","",13],[10,"rand","","",13],[10,"hash","","",13],[10,"clone","","",13],[10,"decode","","",13],[10,"encode","","",13],[10,"eq","","",13],[10,"ne","","",13],[10,"new","","Creates a new vector.",13],[10,"inf","","",13],[10,"sup","","",13],[10,"partial_cmp","","",13],[10,"partial_lt","","",13],[10,"partial_le","","",13],[10,"partial_gt","","",13],[10,"partial_ge","","",13],[10,"x","","Create a unit vector with its `$compN` component equal to 1.0.",13],[10,"y","","Create a unit vector with its `$compN` component equal to 1.0.",13],[10,"z","","Create a unit vector with its `$compN` component equal to 1.0.",13],[10,"w","","Create a unit vector with its `$compN` component equal to 1.0.",13],[10,"from","","",13],[10,"as_array","","View this vector as an array.",13],[10,"as_array_mut","","View this vector as a mutable array.",13],[10,"from_array_ref","","View an array as a vector.",13],[10,"from_array_mut","","View an array as a vector.",13],[10,"index","","",13],[10,"index_mut","","",13],[10,"shape","","",13],[10,"at","","",13],[10,"set","","",13],[10,"swap","","",13],[10,"unsafe_at","","",13],[10,"unsafe_set","","",13],[10,"at_fast","","Unsafe read access to a vector element by index.",13],[10,"set_fast","","Unsafe write access to a vector element by index.",13],[10,"new_repeat","","Creates a new vector with all its components equal to a given value.",13],[10,"dim","","",13],[10,"len","","",13],[10,"canonical_basis","","",13],[10,"orthonormal_subspace_basis","","",13],[10,"canonical_basis_element","","",13],[10,"add","","",13],[10,"sub","","",13],[10,"mul","","",13],[10,"div","","",13],[10,"add","","",13],[10,"sub","","",13],[10,"mul","","",13],[10,"div","","",13],[10,"neg","","",13],[10,"dot","","",13],[10,"mul_s","","",13],[10,"div_s","","",13],[10,"add_s","","",13],[10,"sub_s","","",13],[10,"translation","","",13],[10,"inv_translation","","",13],[10,"append_translation","","",13],[10,"append_translation_cpy","","",13],[10,"prepend_translation","","",13],[10,"prepend_translation_cpy","","",13],[10,"set_translation","","",13],[10,"sqnorm","","",13],[10,"normalize_cpy","","",13],[10,"normalize","","",13],[10,"approx_epsilon","","",13],[10,"approx_ulps","","",13],[10,"approx_eq","","",13],[10,"approx_eq_eps","","",13],[10,"approx_eq_ulps","","",13],[10,"one","","",13],[10,"zero","","",13],[10,"is_zero","","",13],[10,"from_iter","","",13],[10,"max_value","","",13],[10,"min_value","","",13],[10,"axpy","","",13],[10,"iter","","",13],[10,"iter_mut","","",13],[10,"to_homogeneous","","",13],[10,"from","","",13],[10,"translate","","",13],[10,"inv_translate","","",13],[10,"rotate","","",13],[10,"inv_rotate","","",13],[10,"rotate","","",19],[10,"inv_rotate","","",19],[10,"transform","","",13],[10,"inv_transform","","",13],[10,"to_pnt","","",13],[10,"as_pnt","","",13],[10,"to_pnt","","",13],[10,"as_pnt","","",13],[10,"abs","","",13],[10,"fmt","","",14],[10,"rand","","",14],[10,"hash","","",14],[10,"clone","","",14],[10,"decode","","",14],[10,"encode","","",14],[10,"eq","","",14],[10,"ne","","",14],[10,"new","","Creates a new vector.",14],[10,"inf","","",14],[10,"sup","","",14],[10,"partial_cmp","","",14],[10,"partial_lt","","",14],[10,"partial_le","","",14],[10,"partial_gt","","",14],[10,"partial_ge","","",14],[10,"x","","Create a unit vector with its `$compN` component equal to 1.0.",14],[10,"y","","Create a unit vector with its `$compN` component equal to 1.0.",14],[10,"z","","Create a unit vector with its `$compN` component equal to 1.0.",14],[10,"w","","Create a unit vector with its `$compN` component equal to 1.0.",14],[10,"a","","Create a unit vector with its `$compN` component equal to 1.0.",14],[10,"from","","",14],[10,"as_array","","View this vector as an array.",14],[10,"as_array_mut","","View this vector as a mutable array.",14],[10,"from_array_ref","","View an array as a vector.",14],[10,"from_array_mut","","View an array as a vector.",14],[10,"index","","",14],[10,"index_mut","","",14],[10,"shape","","",14],[10,"at","","",14],[10,"set","","",14],[10,"swap","","",14],[10,"unsafe_at","","",14],[10,"unsafe_set","","",14],[10,"at_fast","","Unsafe read access to a vector element by index.",14],[10,"set_fast","","Unsafe write access to a vector element by index.",14],[10,"new_repeat","","Creates a new vector with all its components equal to a given value.",14],[10,"dim","","",14],[10,"len","","",14],[10,"canonical_basis","","",14],[10,"orthonormal_subspace_basis","","",14],[10,"canonical_basis_element","","",14],[10,"add","","",14],[10,"sub","","",14],[10,"mul","","",14],[10,"div","","",14],[10,"add","","",14],[10,"sub","","",14],[10,"mul","","",14],[10,"div","","",14],[10,"neg","","",14],[10,"dot","","",14],[10,"mul_s","","",14],[10,"div_s","","",14],[10,"add_s","","",14],[10,"sub_s","","",14],[10,"translation","","",14],[10,"inv_translation","","",14],[10,"append_translation","","",14],[10,"append_translation_cpy","","",14],[10,"prepend_translation","","",14],[10,"prepend_translation_cpy","","",14],[10,"set_translation","","",14],[10,"sqnorm","","",14],[10,"normalize_cpy","","",14],[10,"normalize","","",14],[10,"approx_epsilon","","",14],[10,"approx_ulps","","",14],[10,"approx_eq","","",14],[10,"approx_eq_eps","","",14],[10,"approx_eq_ulps","","",14],[10,"one","","",14],[10,"zero","","",14],[10,"is_zero","","",14],[10,"from_iter","","",14],[10,"max_value","","",14],[10,"min_value","","",14],[10,"axpy","","",14],[10,"iter","","",14],[10,"iter_mut","","",14],[10,"to_homogeneous","","",14],[10,"from","","",14],[10,"translate","","",14],[10,"inv_translate","","",14],[10,"rotate","","",14],[10,"inv_rotate","","",14],[10,"rotate","","",20],[10,"inv_rotate","","",20],[10,"transform","","",14],[10,"inv_transform","","",14],[10,"to_pnt","","",14],[10,"as_pnt","","",14],[10,"to_pnt","","",14],[10,"as_pnt","","",14],[10,"abs","","",14],[10,"fmt","","",15],[10,"rand","","",15],[10,"hash","","",15],[10,"clone","","",15],[10,"decode","","",15],[10,"encode","","",15],[10,"eq","","",15],[10,"ne","","",15],[10,"new","","Creates a new vector.",15],[10,"inf","","",15],[10,"sup","","",15],[10,"partial_cmp","","",15],[10,"partial_lt","","",15],[10,"partial_le","","",15],[10,"partial_gt","","",15],[10,"partial_ge","","",15],[10,"x","","Create a unit vector with its `$compN` component equal to 1.0.",15],[10,"y","","Create a unit vector with its `$compN` component equal to 1.0.",15],[10,"z","","Create a unit vector with its `$compN` component equal to 1.0.",15],[10,"w","","Create a unit vector with its `$compN` component equal to 1.0.",15],[10,"a","","Create a unit vector with its `$compN` component equal to 1.0.",15],[10,"b","","Create a unit vector with its `$compN` component equal to 1.0.",15],[10,"from","","",15],[10,"as_array","","View this vector as an array.",15],[10,"as_array_mut","","View this vector as a mutable array.",15],[10,"from_array_ref","","View an array as a vector.",15],[10,"from_array_mut","","View an array as a vector.",15],[10,"index","","",15],[10,"index_mut","","",15],[10,"shape","","",15],[10,"at","","",15],[10,"set","","",15],[10,"swap","","",15],[10,"unsafe_at","","",15],[10,"unsafe_set","","",15],[10,"at_fast","","Unsafe read access to a vector element by index.",15],[10,"set_fast","","Unsafe write access to a vector element by index.",15],[10,"new_repeat","","Creates a new vector with all its components equal to a given value.",15],[10,"dim","","",15],[10,"len","","",15],[10,"canonical_basis","","",15],[10,"orthonormal_subspace_basis","","",15],[10,"canonical_basis_element","","",15],[10,"add","","",15],[10,"sub","","",15],[10,"mul","","",15],[10,"div","","",15],[10,"add","","",15],[10,"sub","","",15],[10,"mul","","",15],[10,"div","","",15],[10,"neg","","",15],[10,"dot","","",15],[10,"mul_s","","",15],[10,"div_s","","",15],[10,"add_s","","",15],[10,"sub_s","","",15],[10,"translation","","",15],[10,"inv_translation","","",15],[10,"append_translation","","",15],[10,"append_translation_cpy","","",15],[10,"prepend_translation","","",15],[10,"prepend_translation_cpy","","",15],[10,"set_translation","","",15],[10,"sqnorm","","",15],[10,"normalize_cpy","","",15],[10,"normalize","","",15],[10,"approx_epsilon","","",15],[10,"approx_ulps","","",15],[10,"approx_eq","","",15],[10,"approx_eq_eps","","",15],[10,"approx_eq_ulps","","",15],[10,"one","","",15],[10,"zero","","",15],[10,"is_zero","","",15],[10,"from_iter","","",15],[10,"max_value","","",15],[10,"min_value","","",15],[10,"axpy","","",15],[10,"iter","","",15],[10,"iter_mut","","",15],[10,"translate","","",15],[10,"inv_translate","","",15],[10,"rotate","","",15],[10,"inv_rotate","","",15],[10,"rotate","","",21],[10,"inv_rotate","","",21],[10,"transform","","",15],[10,"inv_transform","","",15],[10,"to_pnt","","",15],[10,"as_pnt","","",15],[10,"to_pnt","","",15],[10,"as_pnt","","",15],[10,"abs","","",15],[10,"fmt","","",32],[10,"rand","","",32],[10,"clone","","",32],[10,"decode","","",32],[10,"eq","","",32],[10,"ne","","",32],[10,"new","","Creates a new point.",32],[10,"new_repeat","","Creates a new point. The parameter is not taken in account.",32],[10,"fmt","","",16],[10,"rand","","",16],[10,"hash","","",16],[10,"clone","","",16],[10,"decode","","",16],[10,"encode","","",16],[10,"eq","","",16],[10,"ne","","",16],[10,"new","","Creates a new vector.",16],[10,"orig","","",16],[10,"is_orig","","",16],[10,"inf","","",16],[10,"sup","","",16],[10,"partial_cmp","","",16],[10,"partial_lt","","",16],[10,"partial_le","","",16],[10,"partial_gt","","",16],[10,"partial_ge","","",16],[10,"mul","","",16],[10,"div","","",16],[10,"add","","",16],[10,"sub","","",16],[10,"from","","",16],[10,"as_array","","View this vector as an array.",16],[10,"as_array_mut","","View this vector as a mutable array.",16],[10,"from_array_ref","","View an array as a vector.",16],[10,"from_array_mut","","View an array as a vector.",16],[10,"index","","",16],[10,"index_mut","","",16],[10,"shape","","",16],[10,"at","","",16],[10,"set","","",16],[10,"swap","","",16],[10,"unsafe_at","","",16],[10,"unsafe_set","","",16],[10,"at_fast","","Unsafe read access to a vector element by index.",16],[10,"set_fast","","Unsafe write access to a vector element by index.",16],[10,"new_repeat","","Creates a new vector with all its components equal to a given value.",16],[10,"dim","","",16],[10,"len","","",16],[10,"to_vec","","Converts this point to its associated vector.",16],[10,"as_vec","","Converts a reference to this point to a reference to its associated vector.",16],[10,"to_vec","","",16],[10,"as_vec","","",16],[10,"set_coords","","",16],[10,"sub","","",16],[10,"neg","","",16],[10,"add","","",16],[10,"sub","","",16],[10,"mul_s","","",16],[10,"div_s","","",16],[10,"add_s","","",16],[10,"sub_s","","",16],[10,"approx_epsilon","","",16],[10,"approx_ulps","","",16],[10,"approx_eq","","",16],[10,"approx_eq_eps","","",16],[10,"approx_eq_ulps","","",16],[10,"from_iter","","",16],[10,"max_value","","",16],[10,"min_value","","",16],[10,"axpy","","",16],[10,"iter","","",16],[10,"iter_mut","","",16],[10,"to_homogeneous","","",16],[10,"from","","",16],[10,"fmt","","",17],[10,"rand","","",17],[10,"hash","","",17],[10,"clone","","",17],[10,"decode","","",17],[10,"encode","","",17],[10,"eq","","",17],[10,"ne","","",17],[10,"new","","Creates a new vector.",17],[10,"orig","","",17],[10,"is_orig","","",17],[10,"inf","","",17],[10,"sup","","",17],[10,"partial_cmp","","",17],[10,"partial_lt","","",17],[10,"partial_le","","",17],[10,"partial_gt","","",17],[10,"partial_ge","","",17],[10,"mul","","",17],[10,"div","","",17],[10,"add","","",17],[10,"sub","","",17],[10,"from","","",17],[10,"as_array","","View this vector as an array.",17],[10,"as_array_mut","","View this vector as a mutable array.",17],[10,"from_array_ref","","View an array as a vector.",17],[10,"from_array_mut","","View an array as a vector.",17],[10,"index","","",17],[10,"index_mut","","",17],[10,"shape","","",17],[10,"at","","",17],[10,"set","","",17],[10,"swap","","",17],[10,"unsafe_at","","",17],[10,"unsafe_set","","",17],[10,"at_fast","","Unsafe read access to a vector element by index.",17],[10,"set_fast","","Unsafe write access to a vector element by index.",17],[10,"new_repeat","","Creates a new vector with all its components equal to a given value.",17],[10,"dim","","",17],[10,"len","","",17],[10,"to_vec","","Converts this point to its associated vector.",17],[10,"as_vec","","Converts a reference to this point to a reference to its associated vector.",17],[10,"to_vec","","",17],[10,"as_vec","","",17],[10,"set_coords","","",17],[10,"sub","","",17],[10,"neg","","",17],[10,"add","","",17],[10,"sub","","",17],[10,"mul_s","","",17],[10,"div_s","","",17],[10,"add_s","","",17],[10,"sub_s","","",17],[10,"approx_epsilon","","",17],[10,"approx_ulps","","",17],[10,"approx_eq","","",17],[10,"approx_eq_eps","","",17],[10,"approx_eq_ulps","","",17],[10,"from_iter","","",17],[10,"max_value","","",17],[10,"min_value","","",17],[10,"axpy","","",17],[10,"iter","","",17],[10,"iter_mut","","",17],[10,"to_homogeneous","","",17],[10,"from","","",17],[10,"fmt","","",18],[10,"rand","","",18],[10,"hash","","",18],[10,"clone","","",18],[10,"decode","","",18],[10,"encode","","",18],[10,"eq","","",18],[10,"ne","","",18],[10,"new","","Creates a new vector.",18],[10,"orig","","",18],[10,"is_orig","","",18],[10,"inf","","",18],[10,"sup","","",18],[10,"partial_cmp","","",18],[10,"partial_lt","","",18],[10,"partial_le","","",18],[10,"partial_gt","","",18],[10,"partial_ge","","",18],[10,"mul","","",18],[10,"div","","",18],[10,"add","","",18],[10,"sub","","",18],[10,"from","","",18],[10,"as_array","","View this vector as an array.",18],[10,"as_array_mut","","View this vector as a mutable array.",18],[10,"from_array_ref","","View an array as a vector.",18],[10,"from_array_mut","","View an array as a vector.",18],[10,"index","","",18],[10,"index_mut","","",18],[10,"shape","","",18],[10,"at","","",18],[10,"set","","",18],[10,"swap","","",18],[10,"unsafe_at","","",18],[10,"unsafe_set","","",18],[10,"at_fast","","Unsafe read access to a vector element by index.",18],[10,"set_fast","","Unsafe write access to a vector element by index.",18],[10,"new_repeat","","Creates a new vector with all its components equal to a given value.",18],[10,"dim","","",18],[10,"len","","",18],[10,"to_vec","","Converts this point to its associated vector.",18],[10,"as_vec","","Converts a reference to this point to a reference to its associated vector.",18],[10,"to_vec","","",18],[10,"as_vec","","",18],[10,"set_coords","","",18],[10,"sub","","",18],[10,"neg","","",18],[10,"add","","",18],[10,"sub","","",18],[10,"mul_s","","",18],[10,"div_s","","",18],[10,"add_s","","",18],[10,"sub_s","","",18],[10,"approx_epsilon","","",18],[10,"approx_ulps","","",18],[10,"approx_eq","","",18],[10,"approx_eq_eps","","",18],[10,"approx_eq_ulps","","",18],[10,"from_iter","","",18],[10,"max_value","","",18],[10,"min_value","","",18],[10,"axpy","","",18],[10,"iter","","",18],[10,"iter_mut","","",18],[10,"to_homogeneous","","",18],[10,"from","","",18],[10,"fmt","","",19],[10,"rand","","",19],[10,"hash","","",19],[10,"clone","","",19],[10,"decode","","",19],[10,"encode","","",19],[10,"eq","","",19],[10,"ne","","",19],[10,"new","","Creates a new vector.",19],[10,"orig","","",19],[10,"is_orig","","",19],[10,"inf","","",19],[10,"sup","","",19],[10,"partial_cmp","","",19],[10,"partial_lt","","",19],[10,"partial_le","","",19],[10,"partial_gt","","",19],[10,"partial_ge","","",19],[10,"mul","","",19],[10,"div","","",19],[10,"add","","",19],[10,"sub","","",19],[10,"from","","",19],[10,"as_array","","View this vector as an array.",19],[10,"as_array_mut","","View this vector as a mutable array.",19],[10,"from_array_ref","","View an array as a vector.",19],[10,"from_array_mut","","View an array as a vector.",19],[10,"index","","",19],[10,"index_mut","","",19],[10,"shape","","",19],[10,"at","","",19],[10,"set","","",19],[10,"swap","","",19],[10,"unsafe_at","","",19],[10,"unsafe_set","","",19],[10,"at_fast","","Unsafe read access to a vector element by index.",19],[10,"set_fast","","Unsafe write access to a vector element by index.",19],[10,"new_repeat","","Creates a new vector with all its components equal to a given value.",19],[10,"dim","","",19],[10,"len","","",19],[10,"to_vec","","Converts this point to its associated vector.",19],[10,"as_vec","","Converts a reference to this point to a reference to its associated vector.",19],[10,"to_vec","","",19],[10,"as_vec","","",19],[10,"set_coords","","",19],[10,"sub","","",19],[10,"neg","","",19],[10,"add","","",19],[10,"sub","","",19],[10,"mul_s","","",19],[10,"div_s","","",19],[10,"add_s","","",19],[10,"sub_s","","",19],[10,"approx_epsilon","","",19],[10,"approx_ulps","","",19],[10,"approx_eq","","",19],[10,"approx_eq_eps","","",19],[10,"approx_eq_ulps","","",19],[10,"from_iter","","",19],[10,"max_value","","",19],[10,"min_value","","",19],[10,"axpy","","",19],[10,"iter","","",19],[10,"iter_mut","","",19],[10,"to_homogeneous","","",19],[10,"from","","",19],[10,"fmt","","",20],[10,"rand","","",20],[10,"hash","","",20],[10,"clone","","",20],[10,"decode","","",20],[10,"encode","","",20],[10,"eq","","",20],[10,"ne","","",20],[10,"new","","Creates a new vector.",20],[10,"orig","","",20],[10,"is_orig","","",20],[10,"inf","","",20],[10,"sup","","",20],[10,"partial_cmp","","",20],[10,"partial_lt","","",20],[10,"partial_le","","",20],[10,"partial_gt","","",20],[10,"partial_ge","","",20],[10,"mul","","",20],[10,"div","","",20],[10,"add","","",20],[10,"sub","","",20],[10,"from","","",20],[10,"as_array","","View this vector as an array.",20],[10,"as_array_mut","","View this vector as a mutable array.",20],[10,"from_array_ref","","View an array as a vector.",20],[10,"from_array_mut","","View an array as a vector.",20],[10,"index","","",20],[10,"index_mut","","",20],[10,"shape","","",20],[10,"at","","",20],[10,"set","","",20],[10,"swap","","",20],[10,"unsafe_at","","",20],[10,"unsafe_set","","",20],[10,"at_fast","","Unsafe read access to a vector element by index.",20],[10,"set_fast","","Unsafe write access to a vector element by index.",20],[10,"new_repeat","","Creates a new vector with all its components equal to a given value.",20],[10,"dim","","",20],[10,"len","","",20],[10,"to_vec","","Converts this point to its associated vector.",20],[10,"as_vec","","Converts a reference to this point to a reference to its associated vector.",20],[10,"to_vec","","",20],[10,"as_vec","","",20],[10,"set_coords","","",20],[10,"sub","","",20],[10,"neg","","",20],[10,"add","","",20],[10,"sub","","",20],[10,"mul_s","","",20],[10,"div_s","","",20],[10,"add_s","","",20],[10,"sub_s","","",20],[10,"approx_epsilon","","",20],[10,"approx_ulps","","",20],[10,"approx_eq","","",20],[10,"approx_eq_eps","","",20],[10,"approx_eq_ulps","","",20],[10,"from_iter","","",20],[10,"max_value","","",20],[10,"min_value","","",20],[10,"axpy","","",20],[10,"iter","","",20],[10,"iter_mut","","",20],[10,"to_homogeneous","","",20],[10,"from","","",20],[10,"fmt","","",21],[10,"rand","","",21],[10,"hash","","",21],[10,"clone","","",21],[10,"decode","","",21],[10,"encode","","",21],[10,"eq","","",21],[10,"ne","","",21],[10,"new","","Creates a new vector.",21],[10,"orig","","",21],[10,"is_orig","","",21],[10,"inf","","",21],[10,"sup","","",21],[10,"partial_cmp","","",21],[10,"partial_lt","","",21],[10,"partial_le","","",21],[10,"partial_gt","","",21],[10,"partial_ge","","",21],[10,"mul","","",21],[10,"div","","",21],[10,"add","","",21],[10,"sub","","",21],[10,"from","","",21],[10,"as_array","","View this vector as an array.",21],[10,"as_array_mut","","View this vector as a mutable array.",21],[10,"from_array_ref","","View an array as a vector.",21],[10,"from_array_mut","","View an array as a vector.",21],[10,"index","","",21],[10,"index_mut","","",21],[10,"shape","","",21],[10,"at","","",21],[10,"set","","",21],[10,"swap","","",21],[10,"unsafe_at","","",21],[10,"unsafe_set","","",21],[10,"at_fast","","Unsafe read access to a vector element by index.",21],[10,"set_fast","","Unsafe write access to a vector element by index.",21],[10,"new_repeat","","Creates a new vector with all its components equal to a given value.",21],[10,"dim","","",21],[10,"len","","",21],[10,"to_vec","","Converts this point to its associated vector.",21],[10,"as_vec","","Converts a reference to this point to a reference to its associated vector.",21],[10,"to_vec","","",21],[10,"as_vec","","",21],[10,"set_coords","","",21],[10,"sub","","",21],[10,"neg","","",21],[10,"add","","",21],[10,"sub","","",21],[10,"mul_s","","",21],[10,"div_s","","",21],[10,"add_s","","",21],[10,"sub_s","","",21],[10,"approx_epsilon","","",21],[10,"approx_ulps","","",21],[10,"approx_eq","","",21],[10,"approx_eq_eps","","",21],[10,"approx_eq_ulps","","",21],[10,"from_iter","","",21],[10,"max_value","","",21],[10,"min_value","","",21],[10,"axpy","","",21],[10,"iter","","",21],[10,"iter_mut","","",21],[10,"fmt","","",22],[10,"rand","","",22],[10,"hash","","",22],[10,"clone","","",22],[10,"decode","","",22],[10,"encode","","",22],[10,"eq","","",22],[10,"ne","","",22],[10,"new","","Creates a new quaternion from its components.",22],[10,"vector","","The vector part `(i, j, k)` of this quaternion.",22],[10,"scalar","","The scalar part `w` of this quaternion.",22],[10,"conjugate","","Replaces this quaternion by its conjugate.",22],[10,"inv_cpy","","",22],[10,"inv","","",22],[10,"sqnorm","","",22],[10,"normalize_cpy","","",22],[10,"normalize","","",22],[10,"mul","","",22],[10,"div","","",22],[10,"fmt","","",33],[10,"hash","","",33],[10,"clone","","",33],[10,"decode","","",33],[10,"encode","","",33],[10,"eq","","",33],[10,"ne","","",33],[10,"new","","Creates a new unit quaternion from the axis-angle representation of a rotation.",33],[10,"new_with_quat","","Creates a new unit quaternion from a quaternion.",33],[10,"new_with_euler_angles","","Creates a new unit quaternion from Euler angles.",33],[10,"to_rot","","Builds a rotation matrix from this quaternion.",33],[10,"new_with_unit_quat","","Creates a new unit quaternion from a quaternion.",33],[10,"quat","","The `Quat` representation of this unit quaternion.",33],[10,"one","","",33],[10,"inv_cpy","","",33],[10,"inv","","",33],[10,"rand","","",33],[10,"approx_epsilon","","",33],[10,"approx_ulps","","",33],[10,"approx_eq_eps","","",33],[10,"approx_eq_ulps","","",33],[10,"div","","",33],[10,"mul","","",33],[10,"mul","","",33],[10,"mul","","",33],[10,"mul","","",12],[10,"mul","","",18],[10,"rotation","","",33],[10,"inv_rotation","","",33],[10,"append_rotation","","",33],[10,"append_rotation_cpy","","",33],[10,"prepend_rotation","","",33],[10,"prepend_rotation_cpy","","",33],[10,"set_rotation","","",33],[10,"rotate","","",33],[10,"inv_rotate","","",33],[10,"rotate","","",33],[10,"inv_rotate","","",33],[10,"transform","","",33],[10,"inv_transform","","",33],[10,"transform","","",33],[10,"inv_transform","","",33],[10,"inf","","",22],[10,"sup","","",22],[10,"partial_cmp","","",22],[10,"partial_lt","","",22],[10,"partial_le","","",22],[10,"partial_gt","","",22],[10,"partial_ge","","",22],[10,"w","","Create a unit vector with its `$compN` component equal to 1.0.",22],[10,"i","","Create a unit vector with its `$compN` component equal to 1.0.",22],[10,"j","","Create a unit vector with its `$compN` component equal to 1.0.",22],[10,"k","","Create a unit vector with its `$compN` component equal to 1.0.",22],[10,"from","","",22],[10,"as_array","","View this vector as an array.",22],[10,"as_array_mut","","View this vector as a mutable array.",22],[10,"from_array_ref","","View an array as a vector.",22],[10,"from_array_mut","","View an array as a vector.",22],[10,"index","","",22],[10,"index_mut","","",22],[10,"shape","","",22],[10,"at","","",22],[10,"set","","",22],[10,"swap","","",22],[10,"unsafe_at","","",22],[10,"unsafe_set","","",22],[10,"at_fast","","Unsafe read access to a vector element by index.",22],[10,"set_fast","","Unsafe write access to a vector element by index.",22],[10,"new_repeat","","Creates a new vector with all its components equal to a given value.",22],[10,"dim","","",22],[10,"len","","",22],[10,"add","","",22],[10,"sub","","",22],[10,"add","","",22],[10,"sub","","",22],[10,"mul","","",22],[10,"div","","",22],[10,"neg","","",22],[10,"mul_s","","",22],[10,"div_s","","",22],[10,"add_s","","",22],[10,"sub_s","","",22],[10,"one","","",22],[10,"zero","","",22],[10,"is_zero","","",22],[10,"approx_epsilon","","",22],[10,"approx_ulps","","",22],[10,"approx_eq","","",22],[10,"approx_eq_eps","","",22],[10,"approx_eq_ulps","","",22],[10,"from_iter","","",22],[10,"max_value","","",22],[10,"min_value","","",22],[10,"axpy","","",22],[10,"iter","","",22],[10,"iter_mut","","",22],[10,"dim","","",33],[10,"fmt","","",34],[10,"rand","","",34],[10,"clone","","",34],[10,"decode","","",34],[10,"eq","","",34],[10,"ne","","",34],[10,"new","","Creates a new identity matrix.",34],[10,"fmt","","",4],[10,"rand","","",4],[10,"hash","","",4],[10,"clone","","",4],[10,"decode","","",4],[10,"encode","","",4],[10,"eq","","",4],[10,"ne","","",4],[10,"new_identity","","",4],[10,"new","","",4],[10,"as_array","","View this matrix as a column-major array of arrays.",4],[10,"as_array_mut","","View this matrix as a column-major mutable array of arrays.",4],[10,"from_array_ref","","View a column-major array of array as a vector.",4],[10,"from_array_mut","","View a column-major array of array as a mutable vector.",4],[10,"from","","",4],[10,"add","","",4],[10,"sub","","",4],[10,"add","","",4],[10,"sub","","",4],[10,"mul","","",4],[10,"div","","",4],[10,"abs","","",4],[10,"zero","","",4],[10,"is_zero","","",4],[10,"one","","",4],[10,"iter","","",4],[10,"iter_mut","","",4],[10,"at_fast","","",4],[10,"set_fast","","",4],[10,"dim","","",4],[10,"shape","","",4],[10,"at","","",4],[10,"set","","",4],[10,"swap","","",4],[10,"unsafe_at","","",4],[10,"unsafe_set","","",4],[10,"index","","",4],[10,"index_mut","","",4],[10,"mul","","",4],[10,"mul","","",4],[10,"mul","","",10],[10,"mul","","",4],[10,"mul","","",16],[10,"transpose_cpy","","",4],[10,"transpose","","",4],[10,"approx_epsilon","","",4],[10,"approx_ulps","","",4],[10,"approx_eq_eps","","",4],[10,"approx_eq_ulps","","",4],[10,"nrows","","",4],[10,"set_row","","",4],[10,"row","","",4],[10,"ncols","","",4],[10,"set_col","","",4],[10,"col","","",4],[10,"col_slice","","",4],[10,"row_slice","","",4],[10,"from_diag","","",4],[10,"set_diag","","",4],[10,"diag","","",4],[10,"to_homogeneous","","",4],[10,"from","","",4],[10,"outer","","",10],[10,"eigen_qr","","",4],[10,"fmt","","",5],[10,"rand","","",5],[10,"hash","","",5],[10,"clone","","",5],[10,"decode","","",5],[10,"encode","","",5],[10,"eq","","",5],[10,"ne","","",5],[10,"new_identity","","",5],[10,"new","","",5],[10,"as_array","","View this matrix as a column-major array of arrays.",5],[10,"as_array_mut","","View this matrix as a column-major mutable array of arrays.",5],[10,"from_array_ref","","View a column-major array of array as a vector.",5],[10,"from_array_mut","","View a column-major array of array as a mutable vector.",5],[10,"from","","",5],[10,"add","","",5],[10,"sub","","",5],[10,"add","","",5],[10,"sub","","",5],[10,"mul","","",5],[10,"div","","",5],[10,"abs","","",5],[10,"zero","","",5],[10,"is_zero","","",5],[10,"one","","",5],[10,"iter","","",5],[10,"iter_mut","","",5],[10,"dim","","",5],[10,"shape","","",5],[10,"at","","",5],[10,"set","","",5],[10,"swap","","",5],[10,"unsafe_at","","",5],[10,"unsafe_set","","",5],[10,"index","","",5],[10,"index_mut","","",5],[10,"at_fast","","",5],[10,"set_fast","","",5],[10,"transpose_cpy","","",5],[10,"transpose","","",5],[10,"approx_epsilon","","",5],[10,"approx_ulps","","",5],[10,"approx_eq_eps","","",5],[10,"approx_eq_ulps","","",5],[10,"nrows","","",5],[10,"set_row","","",5],[10,"row","","",5],[10,"ncols","","",5],[10,"set_col","","",5],[10,"col","","",5],[10,"col_slice","","",5],[10,"row_slice","","",5],[10,"from_diag","","",5],[10,"set_diag","","",5],[10,"diag","","",5],[10,"to_homogeneous","","",5],[10,"from","","",5],[10,"outer","","",11],[10,"eigen_qr","","",5],[10,"fmt","","",6],[10,"rand","","",6],[10,"hash","","",6],[10,"clone","","",6],[10,"decode","","",6],[10,"encode","","",6],[10,"eq","","",6],[10,"ne","","",6],[10,"new_identity","","",6],[10,"new","","",6],[10,"as_array","","View this matrix as a column-major array of arrays.",6],[10,"as_array_mut","","View this matrix as a column-major mutable array of arrays.",6],[10,"from_array_ref","","View a column-major array of array as a vector.",6],[10,"from_array_mut","","View a column-major array of array as a mutable vector.",6],[10,"from","","",6],[10,"add","","",6],[10,"sub","","",6],[10,"add","","",6],[10,"sub","","",6],[10,"mul","","",6],[10,"div","","",6],[10,"abs","","",6],[10,"zero","","",6],[10,"is_zero","","",6],[10,"one","","",6],[10,"iter","","",6],[10,"iter_mut","","",6],[10,"dim","","",6],[10,"shape","","",6],[10,"at","","",6],[10,"set","","",6],[10,"swap","","",6],[10,"unsafe_at","","",6],[10,"unsafe_set","","",6],[10,"index","","",6],[10,"index_mut","","",6],[10,"at_fast","","",6],[10,"set_fast","","",6],[10,"transpose_cpy","","",6],[10,"transpose","","",6],[10,"approx_epsilon","","",6],[10,"approx_ulps","","",6],[10,"approx_eq_eps","","",6],[10,"approx_eq_ulps","","",6],[10,"col_slice","","",6],[10,"row_slice","","",6],[10,"from_diag","","",6],[10,"set_diag","","",6],[10,"diag","","",6],[10,"to_homogeneous","","",6],[10,"from","","",6],[10,"outer","","",12],[10,"eigen_qr","","",6],[10,"fmt","","",7],[10,"rand","","",7],[10,"hash","","",7],[10,"clone","","",7],[10,"decode","","",7],[10,"encode","","",7],[10,"eq","","",7],[10,"ne","","",7],[10,"new_identity","","",7],[10,"new","","",7],[10,"as_array","","View this matrix as a column-major array of arrays.",7],[10,"as_array_mut","","View this matrix as a column-major mutable array of arrays.",7],[10,"from_array_ref","","View a column-major array of array as a vector.",7],[10,"from_array_mut","","View a column-major array of array as a mutable vector.",7],[10,"from","","",7],[10,"add","","",7],[10,"sub","","",7],[10,"add","","",7],[10,"sub","","",7],[10,"mul","","",7],[10,"div","","",7],[10,"abs","","",7],[10,"zero","","",7],[10,"is_zero","","",7],[10,"one","","",7],[10,"iter","","",7],[10,"iter_mut","","",7],[10,"dim","","",7],[10,"shape","","",7],[10,"at","","",7],[10,"set","","",7],[10,"swap","","",7],[10,"unsafe_at","","",7],[10,"unsafe_set","","",7],[10,"index","","",7],[10,"index_mut","","",7],[10,"at_fast","","",7],[10,"set_fast","","",7],[10,"mul","","",7],[10,"mul","","",7],[10,"mul","","",13],[10,"mul","","",7],[10,"mul","","",19],[10,"inv_cpy","","",7],[10,"inv","","",7],[10,"transpose_cpy","","",7],[10,"transpose","","",7],[10,"approx_epsilon","","",7],[10,"approx_ulps","","",7],[10,"approx_eq_eps","","",7],[10,"approx_eq_ulps","","",7],[10,"nrows","","",7],[10,"set_row","","",7],[10,"row","","",7],[10,"ncols","","",7],[10,"set_col","","",7],[10,"col","","",7],[10,"col_slice","","",7],[10,"row_slice","","",7],[10,"from_diag","","",7],[10,"set_diag","","",7],[10,"diag","","",7],[10,"to_homogeneous","","",7],[10,"from","","",7],[10,"outer","","",13],[10,"eigen_qr","","",7],[10,"fmt","","",8],[10,"rand","","",8],[10,"hash","","",8],[10,"clone","","",8],[10,"decode","","",8],[10,"encode","","",8],[10,"eq","","",8],[10,"ne","","",8],[10,"new_identity","","",8],[10,"new","","",8],[10,"as_array","","View this matrix as a column-major array of arrays.",8],[10,"as_array_mut","","View this matrix as a column-major mutable array of arrays.",8],[10,"from_array_ref","","View a column-major array of array as a vector.",8],[10,"from_array_mut","","View a column-major array of array as a mutable vector.",8],[10,"from","","",8],[10,"abs","","",8],[10,"zero","","",8],[10,"is_zero","","",8],[10,"one","","",8],[10,"add","","",8],[10,"sub","","",8],[10,"add","","",8],[10,"sub","","",8],[10,"mul","","",8],[10,"div","","",8],[10,"iter","","",8],[10,"iter_mut","","",8],[10,"dim","","",8],[10,"shape","","",8],[10,"at","","",8],[10,"set","","",8],[10,"swap","","",8],[10,"unsafe_at","","",8],[10,"unsafe_set","","",8],[10,"index","","",8],[10,"index_mut","","",8],[10,"at_fast","","",8],[10,"set_fast","","",8],[10,"mul","","",8],[10,"mul","","",8],[10,"mul","","",14],[10,"mul","","",8],[10,"mul","","",20],[10,"inv_cpy","","",8],[10,"inv","","",8],[10,"transpose_cpy","","",8],[10,"transpose","","",8],[10,"approx_epsilon","","",8],[10,"approx_ulps","","",8],[10,"approx_eq_eps","","",8],[10,"approx_eq_ulps","","",8],[10,"nrows","","",8],[10,"set_row","","",8],[10,"row","","",8],[10,"ncols","","",8],[10,"set_col","","",8],[10,"col","","",8],[10,"col_slice","","",8],[10,"row_slice","","",8],[10,"from_diag","","",8],[10,"set_diag","","",8],[10,"diag","","",8],[10,"to_homogeneous","","",8],[10,"from","","",8],[10,"outer","","",14],[10,"eigen_qr","","",8],[10,"fmt","","",9],[10,"rand","","",9],[10,"hash","","",9],[10,"clone","","",9],[10,"decode","","",9],[10,"encode","","",9],[10,"eq","","",9],[10,"ne","","",9],[10,"new_identity","","",9],[10,"new","","",9],[10,"as_array","","View this matrix as a column-major array of arrays.",9],[10,"as_array_mut","","View this matrix as a column-major mutable array of arrays.",9],[10,"from_array_ref","","View a column-major array of array as a vector.",9],[10,"from_array_mut","","View a column-major array of array as a mutable vector.",9],[10,"from","","",9],[10,"add","","",9],[10,"sub","","",9],[10,"add","","",9],[10,"sub","","",9],[10,"mul","","",9],[10,"div","","",9],[10,"abs","","",9],[10,"zero","","",9],[10,"is_zero","","",9],[10,"one","","",9],[10,"iter","","",9],[10,"iter_mut","","",9],[10,"dim","","",9],[10,"shape","","",9],[10,"at","","",9],[10,"set","","",9],[10,"swap","","",9],[10,"unsafe_at","","",9],[10,"unsafe_set","","",9],[10,"index","","",9],[10,"index_mut","","",9],[10,"at_fast","","",9],[10,"set_fast","","",9],[10,"mul","","",9],[10,"mul","","",9],[10,"mul","","",15],[10,"mul","","",9],[10,"mul","","",21],[10,"inv_cpy","","",9],[10,"inv","","",9],[10,"transpose_cpy","","",9],[10,"transpose","","",9],[10,"approx_epsilon","","",9],[10,"approx_ulps","","",9],[10,"approx_eq_eps","","",9],[10,"approx_eq_ulps","","",9],[10,"nrows","","",9],[10,"set_row","","",9],[10,"row","","",9],[10,"ncols","","",9],[10,"set_col","","",9],[10,"col","","",9],[10,"col_slice","","",9],[10,"row_slice","","",9],[10,"from_diag","","",9],[10,"set_diag","","",9],[10,"diag","","",9],[10,"outer","","",15],[10,"eigen_qr","","",9],[10,"hash","","",35],[10,"fmt","","",35],[10,"clone","","",35],[10,"decode","","",35],[10,"encode","","",35],[10,"eq","","",35],[10,"ne","","",35],[10,"new","","Builds a 2 dimensional rotation matrix from an angle in radian.",35],[10,"rotation","","",35],[10,"inv_rotation","","",35],[10,"append_rotation","","",35],[10,"append_rotation_cpy","","",35],[10,"prepend_rotation","","",35],[10,"prepend_rotation_cpy","","",35],[10,"set_rotation","","",35],[10,"rand","","",35],[10,"absolute_rotate","","",35],[10,"hash","","",36],[10,"fmt","","",36],[10,"clone","","",36],[10,"decode","","",36],[10,"encode","","",36],[10,"eq","","",36],[10,"ne","","",36],[10,"new","","Builds a 3 dimensional rotation matrix from an axis and an angle.",36],[10,"new_with_mat","","Builds a rotation matrix from an orthogonal matrix.",36],[10,"new_with_euler_angles","","Creates a new rotation from Euler angles.",36],[10,"look_at","","Reorient this matrix such that its local `x` axis points to a given point. Note that the\nusually known `look_at` function does the same thing but with the `z` axis. See `look_at_z`\nfor that.",36],[10,"look_at_z","","Reorient this matrix such that its local `z` axis points to a given point.",36],[10,"rotation","","",36],[10,"inv_rotation","","",36],[10,"append_rotation","","",36],[10,"append_rotation_cpy","","",36],[10,"prepend_rotation","","",36],[10,"prepend_rotation_cpy","","",36],[10,"set_rotation","","",36],[10,"rand","","",36],[10,"absolute_rotate","","",36],[10,"hash","","",37],[10,"fmt","","",37],[10,"clone","","",37],[10,"decode","","",37],[10,"encode","","",37],[10,"eq","","",37],[10,"ne","","",37],[10,"absolute_rotate","","",37],[10,"rotation","","",37],[10,"inv_rotation","","",37],[10,"append_rotation","","",37],[10,"append_rotation_cpy","","",37],[10,"prepend_rotation","","",37],[10,"prepend_rotation_cpy","","",37],[10,"set_rotation","","",37],[10,"submat","","",35],[10,"rotate","","",35],[10,"inv_rotate","","",35],[10,"rotate","","",35],[10,"inv_rotate","","",35],[10,"transform","","",35],[10,"inv_transform","","",35],[10,"transform","","",35],[10,"inv_transform","","",35],[10,"dim","","",35],[10,"mul","","",35],[10,"mul","","",35],[10,"mul","","",11],[10,"mul","","",35],[10,"mul","","",17],[10,"one","","",35],[10,"to_rot_mat","","",35],[10,"ncols","","",35],[10,"col","","",35],[10,"set_col","","",35],[10,"nrows","","",35],[10,"row","","",35],[10,"set_row","","",35],[10,"index","","",35],[10,"abs","","",35],[10,"to_homogeneous","","",35],[10,"inv","","",35],[10,"inv_cpy","","",35],[10,"transpose_cpy","","",35],[10,"transpose","","",35],[10,"approx_epsilon","","",35],[10,"approx_ulps","","",35],[10,"approx_eq","","",35],[10,"approx_eq_eps","","",35],[10,"approx_eq_ulps","","",35],[10,"submat","","",36],[10,"rotate","","",36],[10,"inv_rotate","","",36],[10,"rotate","","",36],[10,"inv_rotate","","",36],[10,"transform","","",36],[10,"inv_transform","","",36],[10,"transform","","",36],[10,"inv_transform","","",36],[10,"dim","","",36],[10,"mul","","",36],[10,"mul","","",36],[10,"mul","","",12],[10,"mul","","",36],[10,"mul","","",18],[10,"one","","",36],[10,"to_rot_mat","","",36],[10,"ncols","","",36],[10,"col","","",36],[10,"set_col","","",36],[10,"nrows","","",36],[10,"row","","",36],[10,"set_row","","",36],[10,"index","","",36],[10,"abs","","",36],[10,"to_homogeneous","","",36],[10,"inv","","",36],[10,"inv_cpy","","",36],[10,"transpose_cpy","","",36],[10,"transpose","","",36],[10,"approx_epsilon","","",36],[10,"approx_ulps","","",36],[10,"approx_eq","","",36],[10,"approx_eq_eps","","",36],[10,"approx_eq_ulps","","",36],[10,"submat","","",37],[10,"rotate","","",37],[10,"inv_rotate","","",37],[10,"rotate","","",37],[10,"inv_rotate","","",37],[10,"transform","","",37],[10,"inv_transform","","",37],[10,"transform","","",37],[10,"inv_transform","","",37],[10,"dim","","",37],[10,"mul","","",37],[10,"mul","","",37],[10,"mul","","",13],[10,"mul","","",37],[10,"mul","","",19],[10,"one","","",37],[10,"to_rot_mat","","",37],[10,"ncols","","",37],[10,"col","","",37],[10,"set_col","","",37],[10,"nrows","","",37],[10,"row","","",37],[10,"set_row","","",37],[10,"index","","",37],[10,"abs","","",37],[10,"to_homogeneous","","",37],[10,"inv","","",37],[10,"inv_cpy","","",37],[10,"transpose_cpy","","",37],[10,"transpose","","",37],[10,"approx_epsilon","","",37],[10,"approx_ulps","","",37],[10,"approx_eq","","",37],[10,"approx_eq_eps","","",37],[10,"approx_eq_ulps","","",37],[10,"fmt","","",1],[10,"clone","","",1],[10,"decode","","",1],[10,"encode","","",1],[10,"eq","","",1],[10,"ne","","",1],[10,"fmt","","",2],[10,"clone","","",2],[10,"decode","","",2],[10,"encode","","",2],[10,"eq","","",2],[10,"ne","","",2],[10,"fmt","","",3],[10,"clone","","",3],[10,"decode","","",3],[10,"encode","","",3],[10,"eq","","",3],[10,"ne","","",3],[10,"look_at","","Reorient and translate this transformation such that its local `x` axis points to a given\ndirection.  Note that the usually known `look_at` function does the same thing but with the\n`z` axis. See `look_at_z` for that.",2],[10,"look_at_z","","Reorient and translate this transformation such that its local `z` axis points to a given\ndirection.",2],[10,"new_with_rotmat","","Creates a new isometry from a rotation matrix and a vector.",3],[10,"new","","Creates a new isometry from a rotation matrix and a vector.",1],[10,"new_with_rotmat","","Creates a new isometry from a rotation matrix and a vector.",1],[10,"to_rot_mat","","",1],[10,"rotation","","",1],[10,"inv_rotation","","",1],[10,"append_rotation","","",1],[10,"append_rotation_cpy","","",1],[10,"prepend_rotation","","",1],[10,"prepend_rotation_cpy","","",1],[10,"set_rotation","","",1],[10,"dim","","",1],[10,"one","","",1],[10,"absolute_rotate","","",1],[10,"rand","","",1],[10,"approx_epsilon","","",1],[10,"approx_ulps","","",1],[10,"approx_eq_eps","","",1],[10,"approx_eq_ulps","","",1],[10,"to_homogeneous","","",1],[10,"inv","","",1],[10,"inv_cpy","","",1],[10,"transform","","",1],[10,"inv_transform","","",1],[10,"transformation","","",1],[10,"inv_transformation","","",1],[10,"append_transformation","","",1],[10,"append_transformation_cpy","","",1],[10,"prepend_transformation","","",1],[10,"prepend_transformation_cpy","","",1],[10,"set_transformation","","",1],[10,"rotate","","",1],[10,"inv_rotate","","",1],[10,"translation","","",1],[10,"inv_translation","","",1],[10,"append_translation","","",1],[10,"append_translation_cpy","","",1],[10,"prepend_translation","","",1],[10,"prepend_translation_cpy","","",1],[10,"set_translation","","",1],[10,"translate","","",1],[10,"inv_translate","","",1],[10,"mul","","",1],[10,"mul","","",1],[10,"mul","","",17],[10,"new","","Creates a new isometry from a rotation matrix and a vector.",2],[10,"new_with_rotmat","","Creates a new isometry from a rotation matrix and a vector.",2],[10,"to_rot_mat","","",2],[10,"rotation","","",2],[10,"inv_rotation","","",2],[10,"append_rotation","","",2],[10,"append_rotation_cpy","","",2],[10,"prepend_rotation","","",2],[10,"prepend_rotation_cpy","","",2],[10,"set_rotation","","",2],[10,"dim","","",2],[10,"one","","",2],[10,"absolute_rotate","","",2],[10,"rand","","",2],[10,"approx_epsilon","","",2],[10,"approx_ulps","","",2],[10,"approx_eq_eps","","",2],[10,"approx_eq_ulps","","",2],[10,"to_homogeneous","","",2],[10,"inv","","",2],[10,"inv_cpy","","",2],[10,"transform","","",2],[10,"inv_transform","","",2],[10,"transformation","","",2],[10,"inv_transformation","","",2],[10,"append_transformation","","",2],[10,"append_transformation_cpy","","",2],[10,"prepend_transformation","","",2],[10,"prepend_transformation_cpy","","",2],[10,"set_transformation","","",2],[10,"rotate","","",2],[10,"inv_rotate","","",2],[10,"translation","","",2],[10,"inv_translation","","",2],[10,"append_translation","","",2],[10,"append_translation_cpy","","",2],[10,"prepend_translation","","",2],[10,"prepend_translation_cpy","","",2],[10,"set_translation","","",2],[10,"translate","","",2],[10,"inv_translate","","",2],[10,"mul","","",2],[10,"mul","","",2],[10,"mul","","",18],[10,"dim","","",3],[10,"one","","",3],[10,"absolute_rotate","","",3],[10,"approx_epsilon","","",3],[10,"approx_ulps","","",3],[10,"approx_eq_eps","","",3],[10,"approx_eq_ulps","","",3],[10,"to_homogeneous","","",3],[10,"inv","","",3],[10,"inv_cpy","","",3],[10,"transform","","",3],[10,"inv_transform","","",3],[10,"transformation","","",3],[10,"inv_transformation","","",3],[10,"append_transformation","","",3],[10,"append_transformation_cpy","","",3],[10,"prepend_transformation","","",3],[10,"prepend_transformation_cpy","","",3],[10,"set_transformation","","",3],[10,"rotate","","",3],[10,"inv_rotate","","",3],[10,"translation","","",3],[10,"inv_translation","","",3],[10,"append_translation","","",3],[10,"append_translation_cpy","","",3],[10,"prepend_translation","","",3],[10,"prepend_translation_cpy","","",3],[10,"set_translation","","",3],[10,"translate","","",3],[10,"inv_translate","","",3],[10,"mul","","",3],[10,"mul","","",3],[10,"mul","","",19],[10,"fmt","","",38],[10,"clone","","",38],[10,"decode","","",38],[10,"encode","","",38],[10,"eq","","",38],[10,"ne","","",38],[10,"fmt","","",39],[10,"clone","","",39],[10,"decode","","",39],[10,"encode","","",39],[10,"eq","","",39],[10,"ne","","",39],[10,"new","","Creates a new 3D perspective projection.",38],[10,"to_mat","","Builds a 4D projection matrix (using homogeneous coordinates) for this projection.",38],[10,"to_persp_mat","","Build a `PerspMat3` representing this projection.",38],[10,"aspect","","Gets the `width / height` aspect ratio.",38],[10,"fov","","Gets the field of view of the view frustrum.",38],[10,"znear","","Gets the near plane offset of the view frustrum.",38],[10,"zfar","","Gets the far plane offset of the view frustrum.",38],[10,"set_aspect","","Sets the `width / height` aspect ratio of the view frustrum.",38],[10,"set_fov","","Sets the field of view of the view frustrum.",38],[10,"set_znear","","Sets the near plane offset of the view frustrum.",38],[10,"set_zfar","","Sets the far plane offset of the view frustrum.",38],[10,"project_pnt","","Projects a point.",38],[10,"project_vec","","Projects a vector.",38],[10,"new","","Creates a new persepctive matrix from the aspect ratio, field of view, and near/far planes.",39],[10,"new_with_mat","","Creates a new perspective projection matrix from a 4D matrix.",39],[10,"as_mat","","Returns a reference to the 4D matrix (using homogeneous coordinates) of this projection.",39],[10,"aspect","","Gets the `width / height` aspect ratio of the view frustrum.",39],[10,"fov","","Gets the field of view of the view frustrum.",39],[10,"znear","","Gets the near plane offset of the view frustrum.",39],[10,"zfar","","Gets the far plane offset of the view frustrum.",39],[10,"set_aspect","","Updates this projection matrix with a new `width / height` aspect ratio of the view\nfrustrum.",39],[10,"set_fov","","Updates this projection with a new field of view of the view frustrum.",39],[10,"set_znear","","Updates this projection matrix with a new near plane offset of the view frustrum.",39],[10,"set_zfar","","Updates this projection matrix with a new far plane offset of the view frustrum.",39],[10,"set_znear_and_zfar","","Updates this projection matrix with new near and far plane offsets of the view frustrum.",39],[10,"project_pnt","","Projects a point.",39],[10,"project_vec","","Projects a vector.",39],[10,"to_mat","","Returns the 4D matrix (using homogeneous coordinates) of this projection.",39],[10,"fmt","","",40],[10,"clone","","",40],[10,"decode","","",40],[10,"encode","","",40],[10,"eq","","",40],[10,"ne","","",40],[10,"fmt","","",41],[10,"clone","","",41],[10,"decode","","",41],[10,"encode","","",41],[10,"eq","","",41],[10,"ne","","",41],[10,"new","","Creates a new 3D orthographic projection.",40],[10,"to_mat","","Builds a 4D projection matrix (using homogeneous coordinates) for this projection.",40],[10,"to_persp_mat","","Build a `OrthoMat3` representing this projection.",40],[10,"width","","The width of the view cuboid.",40],[10,"height","","The height of the view cuboid.",40],[10,"znear","","The near plane offset of the view cuboid.",40],[10,"zfar","","The far plane offset of the view cuboid.",40],[10,"set_width","","Sets the width of the view cuboid.",40],[10,"set_height","","Sets the height of the view cuboid.",40],[10,"set_znear","","Sets the near plane offset of the view cuboid.",40],[10,"set_zfar","","Sets the far plane offset of the view cuboid.",40],[10,"project_pnt","","Projects a point.",40],[10,"project_vec","","Projects a vector.",40],[10,"new","","Creates a new orthographic projection matrix from the width, heihgt, znear and zfar planes of the view cuboid.",41],[10,"new_with_mat","","Creates a new orthographic matrix from a 4D matrix.",41],[10,"as_mat","","Returns a reference to the 4D matrix (using homogeneous coordinates) of this projection.",41],[10,"width","","The width of the view cuboid.",41],[10,"height","","The height of the view cuboid.",41],[10,"znear","","The near plane offset of the view cuboid.",41],[10,"zfar","","The far plane offset of the view cuboid.",41],[10,"set_width","","Sets the width of the view cuboid.",41],[10,"set_height","","Sets the height of the view cuboid.",41],[10,"set_znear","","Sets the near plane offset of the view cuboid.",41],[10,"set_zfar","","Sets the far plane offset of the view cuboid.",41],[10,"set_znear_and_zfar","","Sets the near and far plane offsets of the view cuboid.",41],[10,"project_pnt","","Projects a point.",41],[10,"project_vec","","Projects a vector.",41],[10,"to_mat","","Returns the 4D matrix (using homogeneous coordinates) of this projection.",41],[10,"fmt","","",23],[10,"clone","","",23],[10,"decode","","",23],[10,"encode","","",23],[10,"eq","","",23],[10,"ne","","",23],[10,"is_eq","","Returns `true` if `self` is equal to `Equal`.",23],[10,"is_lt","","Returns `true` if `self` is equal to `Less`.",23],[10,"is_le","","Returns `true` if `self` is equal to `Less` or `Equal`.",23],[10,"is_gt","","Returns `true` if `self` is equal to `Greater`.",23],[10,"is_ge","","Returns `true` if `self` is equal to `Greater` or `Equal`.",23],[10,"is_not_comparable","","Returns `true` if `self` is equal to `NotComparable`.",23],[10,"from_ordering","","Creates a `POrdering` from an `Ordering`.",23],[10,"to_ordering","","Converts this `POrdering` to an `Ordering`.",23],[6,"Absolute","","Trait of objects having an absolute value.\nThis is useful if the object does not have the same type as its absolute value."],[9,"abs","","Computes some absolute value of this object.\nTypically, this will make all component of a matrix or vector positive.",42],[6,"AbsoluteRotate","","Composition of a rotation and an absolute value."],[9,"absolute_rotate","","This is the same as:",43],[6,"ApproxEq","","Trait for testing approximate equality"],[9,"approx_epsilon","","Default epsilon for approximation.",44],[9,"approx_eq_eps","","Tests approximate equality using a custom epsilon.",44],[9,"approx_ulps","","Default ULPs for approximation.",44],[9,"approx_eq_ulps","","Tests approximate equality using units in the last place (ULPs)",44],[10,"approx_eq","","Tests approximate equality.",44],[6,"Axpy","","Trait of objects implementing the `y = ax + y` operation."],[9,"axpy","","Adds $$a * x$$ to `self`.",45],[6,"Basis","","Traits of objects which can form a basis (typically vectors)."],[9,"canonical_basis","","Iterates through the canonical basis of the space in which this object lives.",46],[9,"orthonormal_subspace_basis","","Iterates through a basis of the subspace orthogonal to `self`.",46],[9,"canonical_basis_element","","Gets the ith element of the canonical basis.",46],[6,"BaseFloat","","Basic floating-point number numeric trait."],[9,"pi","","Archimedes' constant.",47],[9,"two_pi","","2.0 * pi.",47],[9,"frac_pi_2","","pi / 2.0.",47],[9,"frac_pi_3","","pi / 3.0.",47],[9,"frac_pi_4","","pi / 4.0.",47],[9,"frac_pi_6","","pi / 6.0.",47],[9,"frac_pi_8","","pi / 8.0.",47],[9,"frac_1_pi","","1.0 / pi.",47],[9,"frac_2_pi","","2.0 / pi.",47],[9,"frac_2_sqrtpi","","2.0 / sqrt(pi).",47],[9,"e","","Euler's number.",47],[9,"log2_e","","log2(e).",47],[9,"log10_e","","log10(e).",47],[9,"ln_2","","ln(2.0).",47],[9,"ln_10","","ln(10.0).",47],[6,"BaseNum","","Basic integral numeric trait."],[6,"Bounded","","Types that have maximum and minimum value."],[9,"min_value","","The minimum value.",48],[9,"max_value","","The maximum value.",48],[6,"Cast","","Traits of objects which can be created from an object of type `T`."],[9,"from","","Converts an element of type `T` to an element of type `Self`.",49],[6,"Col","","Trait to access columns of a matrix or vector."],[9,"ncols","","The number of column of this matrix or vector.",50],[9,"col","","Reads the `i`-th column of `self`.",50],[9,"set_col","","Writes the `i`-th column of `self`.",50],[6,"ColSlice","","Trait to access part of a column of a matrix"],[9,"col_slice","","Returns a view to a slice of a column of a matrix.",51],[6,"RowSlice","","Trait to access part of a row of a matrix"],[9,"row_slice","","Returns a view to a slice of a row of a matrix.",52],[6,"Cov","","Trait for computing the covariance of a set of data."],[9,"cov","","Computes the covariance of the obsevations stored by `m`:",53],[10,"cov_to","","Computes the covariance of the obsevations stored by `m`:",53],[6,"Cross","","Trait of elements having a cross product."],[17,"Output","nalgebra::Cross",""],[9,"cross","nalgebra","Computes the cross product between two elements (usually vectors).",54],[6,"CrossMatrix","","Trait of elements having a cross product operation which can be expressed as a matrix."],[9,"cross_matrix","","The matrix associated to any cross product with this vector. I.e. `v.cross(anything)` =\n`v.cross_matrix().rmul(anything)`.",55],[6,"Det","","Trait of objects having a determinant. Typically used by square matrices."],[9,"det","","Returns the determinant of `m`.",56],[6,"Diag","","Trait to get the diagonal of square matrices."],[9,"from_diag","","Creates a new matrix with the given diagonal.",57],[9,"set_diag","","Sets the diagonal of this matrix.",57],[9,"diag","","The diagonal of this matrix.",57],[6,"Dim","","Trait of objects having a spacial dimension known at compile time."],[9,"dim","","The dimension of the object.",58],[6,"Dot","","Traits of objects having a dot product."],[9,"dot","","Computes the dot (inner) product of two vectors.",59],[6,"EigenQR","","Trait for computing the eigenvector and eigenvalues of a square matrix usin the QR algorithm."],[9,"eigen_qr","","Computes the eigenvectors and eigenvalues of this matrix.",60],[6,"Eye","","Trait for constructing the identity matrix"],[9,"new_identity","","Return the identity matrix of specified dimension",61],[6,"FloatPnt","","Trait of points with components implementing the `BaseFloat` trait."],[10,"sqdist","","Computes the square distance between two points.",62],[10,"dist","","Computes the distance between two points.",62],[6,"FloatVec","","Trait of vector with components implementing the `BaseFloat` trait."],[6,"FromHomogeneous","","Traits of objects which can be build from an homogeneous coordinate form."],[9,"from","","Builds an object from its homogeneous coordinate form.",63],[6,"Indexable","","This is a workaround of current Rust limitations."],[9,"at","","Reads the `i`-th element of `self`.",64],[9,"set","","Writes to the `i`-th element of `self`.",64],[9,"swap","","Swaps the `i`-th element of `self` with its `j`-th element.",64],[9,"unsafe_at","","Reads the `i`-th element of `self`.",64],[9,"unsafe_set","","Writes to the `i`-th element of `self`.",64],[6,"Inv","","Trait of objects having an inverse. Typically used to implement matrix inverse."],[9,"inv_cpy","","Returns the inverse of `m`.",65],[9,"inv","","In-place version of `inverse`.",65],[6,"Iterable","","This is a workaround of current Rust limitations."],[9,"iter","","Gets a vector-like read-only iterator.",66],[6,"IterableMut","","This is a workaround of current Rust limitations."],[9,"iter_mut","","Gets a vector-like read-write iterator.",67],[6,"LMul","","Trait of objects having a left multiplication with another element."],[9,"lmul","","Computes `v * self`",68],[6,"Mat","","Trait of matrices."],[6,"Mean","","Trait for computing the covariance of a set of data."],[9,"mean","","Computes the mean of the observations stored by `v`.\n \n  * For matrices, observations are stored in its rows.\n  * For vectors, observations are stored in its components (thus are 1-dimensional).",69],[6,"Norm","","Traits of objects having an euclidian norm."],[10,"norm","","Computes the norm of `self`.",70],[9,"sqnorm","","Computes the squared norm of `self`.",70],[9,"normalize_cpy","","Gets the normalized version of a copy of `v`.",70],[9,"normalize","","Normalizes `self`.",70],[6,"NumPnt","","Trait grouping most common operations on points."],[6,"NumVec","","Trait grouping most common operations on vectors."],[6,"One","","Multiplicative identity."],[9,"one","","Returns the multiplicative identity.",71],[6,"Orig","","The zero element of a vector space, seen as an element of its embeding affine space."],[9,"orig","","The trivial origin.",72],[9,"is_orig","","Returns true if this points is exactly the trivial origin.",72],[6,"Outer","","Traits of objects having an outer product."],[9,"outer","","Computes the outer product: `a * b`",73],[6,"POrd","","Pointwise ordering operations."],[9,"inf","","Returns the infimum of this value and another",74],[9,"sup","","Returns the supremum of this value and another",74],[9,"partial_cmp","","Compare `self` and `other` using a partial ordering relation.",74],[10,"partial_le","","Returns `true` iff `self` and `other` are comparable and `self <= other`.",74],[10,"partial_lt","","Returns `true` iff `self` and `other` are comparable and `self < other`.",74],[10,"partial_ge","","Returns `true` iff `self` and `other` are comparable and `self >= other`.",74],[10,"partial_gt","","Returns `true` iff `self` and `other` are comparable and `self > other`.",74],[10,"partial_min","","Return the minimum of `self` and `other` if they are comparable.",74],[10,"partial_max","","Return the maximum of `self` and `other` if they are comparable.",74],[10,"partial_clamp","","Clamp `value` between `min` and `max`. Returns `None` if `value` is not comparable to\n`min` or `max`.",74],[6,"PntAsVec","","Trait that relates a point of an affine space to a vector of the associated vector space."],[9,"to_vec","","Converts this point to its associated vector.",75],[9,"as_vec","","Converts a reference to this point to a reference to its associated vector.",75],[9,"set_coords","","Sets the coordinates of this point to match those of a given vector.",75],[6,"RMul","","Trait of objects having a right multiplication with another element."],[9,"rmul","","Computes `self * v`",76],[6,"Rotate","","Trait of objects able to rotate other objects."],[9,"rotate","","Applies a rotation to `v`.",77],[9,"inv_rotate","","Applies an inverse rotation to `v`.",77],[6,"Rotation","","Trait of object which can represent a rotation, and to which new rotations can be appended. A\nrotation is assumed to be an isometry without translation and without reflexion."],[9,"rotation","","Gets the rotation associated with `self`.",78],[9,"inv_rotation","","Gets the inverse rotation associated with `self`.",78],[9,"append_rotation","","Appends a rotation to this object.",78],[9,"append_rotation_cpy","","Appends the rotation `amount` to a copy of `t`.",78],[9,"prepend_rotation","","Prepends a rotation to this object.",78],[9,"prepend_rotation_cpy","","Prepends the rotation `amount` to a copy of `t`.",78],[9,"set_rotation","","Sets the rotation of `self`.",78],[6,"RotationMatrix","","Trait of transformation having a rotation extractable as a rotation matrix. This can typically\nbe implemented by quaternions to convert them to a rotation matrix."],[17,"Output","nalgebra::RotationMatrix",""],[9,"to_rot_mat","nalgebra","Gets the rotation matrix represented by `self`.",79],[6,"RotationWithTranslation","","Various composition of rotation and translation."],[10,"append_rotation_wrt_point_cpy","","Applies a rotation centered on a specific point.",80],[10,"append_rotation_wrt_point","","Rotates `self` using a specific center of rotation.",80],[10,"append_rotation_wrt_center_cpy","","Applies a rotation centered on the translation of `m`.\n \n# Arguments\n  * `t` - the object to be rotated.\n  * `amount` - the rotation to apply.",80],[10,"append_rotation_wrt_center","","Applies a rotation centered on the translation of `m`.",80],[6,"Row","","Trait to access rows of a matrix or a vector."],[9,"nrows","","The number of column of `self`.",81],[9,"row","","Reads the `i`-th row of `self`.",81],[9,"set_row","","Writes the `i`-th row of `self`.",81],[6,"ScalarAdd","","Trait of objects having an addition with a scalar."],[9,"add_s","","Gets the result of `self + n`.",82],[6,"ScalarSub","","Trait of objects having a subtraction with a scalar."],[9,"sub_s","","Gets the result of `self - n`.",83],[6,"ScalarMul","","Trait of objects having a multiplication with a scalar."],[9,"mul_s","","Gets the result of `self * n`.",84],[6,"ScalarDiv","","Trait of objects having a division by a scalar."],[9,"div_s","","Gets the result of `self / n`.",85],[6,"Shape","","The shape of an indexable object."],[9,"shape","","Returns the shape of an indexable object.",86],[6,"SquareMat","","Trait implemented by square matrices."],[6,"ToHomogeneous","","Traits of objects which can be put in homogeneous coordinates form."],[9,"to_homogeneous","","Gets the homogeneous coordinates form of this object.",87],[6,"Transform","","Trait of objects able to transform other objects."],[9,"transform","","Applies a transformation to `v`.",88],[9,"inv_transform","","Applies an inverse transformation to `v`.",88],[6,"Transformation","","Trait of object which represent a transformation, and to which new transformations can\nbe appended."],[9,"transformation","","Gets the transformation of `self`.",89],[9,"inv_transformation","","Gets the inverse transformation of `self`.",89],[9,"append_transformation","","Appends a transformation to this object.",89],[9,"append_transformation_cpy","","Appends the transformation `amount` to a copy of `t`.",89],[9,"prepend_transformation","","Prepends a transformation to this object.",89],[9,"prepend_transformation_cpy","","Prepends the transformation `amount` to a copy of `t`.",89],[9,"set_transformation","","Sets the transformation of `self`.",89],[6,"Translate","","Trait of objects able to translate other objects. This is typically\nimplemented by vectors to translate points."],[9,"translate","","Apply a translation to an object.",90],[9,"inv_translate","","Apply an inverse translation to an object.",90],[6,"Translation","","Trait of object which represent a translation, and to wich new translation\ncan be appended."],[9,"translation","","Gets the translation associated with this object.",91],[9,"inv_translation","","Gets the inverse translation associated with this object.",91],[9,"append_translation","","Appends a translation to this object.",91],[9,"append_translation_cpy","","Appends the translation `amount` to a copy of `t`.",91],[9,"prepend_translation","","Prepends a translation to this object.",91],[9,"prepend_translation_cpy","","Prepends the translation `amount` to a copy of `t`.",91],[9,"set_translation","","Sets the translation.",91],[6,"Transpose","","Trait of objects which can be transposed."],[9,"transpose_cpy","","Computes the transpose of a matrix.",92],[9,"transpose","","In-place version of `transposed`.",92],[6,"UniformSphereSample","","Trait of vectors able to sample a unit sphere."],[9,"sample","","Iterate through the samples.",93],[6,"VecAsPnt","","Trait that relates a point of an affine space to a vector of the associated vector space."],[9,"to_pnt","","Converts this point to its associated vector.",94],[9,"as_pnt","","Converts a reference to this point to a reference to its associated vector.",94],[6,"Zero","","Additive identity."],[9,"zero","","Returns the additive identity.",95],[9,"is_zero","","Tests if `self` is exactly zero.",95],[15,"assert_approx_eq_eps!","","Asserts approximate equality within a given tolerance of two values with the\n`ApproxEq` trait."],[15,"assert_approx_eq_ulps!","","Asserts approximate equality within a given tolerance of two values with the\n`ApproxEq` trait, with tolerance specified in ULPs."],[15,"assert_approx_eq!","","Asserts approximate equality of two values with the `ApproxEq` trait."],[10,"append_rotation_wrt_point_cpy","","Applies a rotation centered on a specific point.",80],[10,"append_rotation_wrt_point","","Rotates `self` using a specific center of rotation.",80],[10,"append_rotation_wrt_center_cpy","","Applies a rotation centered on the translation of `m`.\n \n# Arguments\n  * `t` - the object to be rotated.\n  * `amount` - the rotation to apply.",80],[10,"append_rotation_wrt_center","","Applies a rotation centered on the translation of `m`.",80],[10,"norm","","Computes the norm of `self`.",70],[10,"sqdist","","Computes the square distance between two points.",62],[10,"dist","","Computes the distance between two points.",62],[10,"partial_le","","Returns `true` iff `self` and `other` are comparable and `self <= other`.",74],[10,"partial_lt","","Returns `true` iff `self` and `other` are comparable and `self < other`.",74],[10,"partial_ge","","Returns `true` iff `self` and `other` are comparable and `self >= other`.",74],[10,"partial_gt","","Returns `true` iff `self` and `other` are comparable and `self > other`.",74],[10,"partial_min","","Return the minimum of `self` and `other` if they are comparable.",74],[10,"partial_max","","Return the maximum of `self` and `other` if they are comparable.",74],[10,"partial_clamp","","Clamp `value` between `min` and `max`. Returns `None` if `value` is not comparable to\n`min` or `max`.",74],[10,"approx_eq","","Tests approximate equality.",44],[10,"cov_to","","Computes the covariance of the obsevations stored by `m`:",53]],"paths":[[1,"DVec"],[1,"Iso2"],[1,"Iso3"],[1,"Iso4"],[1,"Mat1"],[1,"Mat2"],[1,"Mat3"],[1,"Mat4"],[1,"Mat5"],[1,"Mat6"],[1,"Vec1"],[1,"Vec2"],[1,"Vec3"],[1,"Vec4"],[1,"Vec5"],[1,"Vec6"],[1,"Pnt1"],[1,"Pnt2"],[1,"Pnt3"],[1,"Pnt4"],[1,"Pnt5"],[1,"Pnt6"],[1,"Quat"],[2,"POrdering"],[1,"DMat"],[1,"DVec1"],[1,"DVec2"],[1,"DVec3"],[1,"DVec4"],[1,"DVec5"],[1,"DVec6"],[1,"Vec0"],[1,"Pnt0"],[1,"UnitQuat"],[1,"Identity"],[1,"Rot2"],[1,"Rot3"],[1,"Rot4"],[1,"Persp3"],[1,"PerspMat3"],[1,"Ortho3"],[1,"OrthoMat3"],[6,"Absolute"],[6,"AbsoluteRotate"],[6,"ApproxEq"],[6,"Axpy"],[6,"Basis"],[6,"BaseFloat"],[6,"Bounded"],[6,"Cast"],[6,"Col"],[6,"ColSlice"],[6,"RowSlice"],[6,"Cov"],[6,"Cross"],[6,"CrossMatrix"],[6,"Det"],[6,"Diag"],[6,"Dim"],[6,"Dot"],[6,"EigenQR"],[6,"Eye"],[6,"FloatPnt"],[6,"FromHomogeneous"],[6,"Indexable"],[6,"Inv"],[6,"Iterable"],[6,"IterableMut"],[6,"LMul"],[6,"Mean"],[6,"Norm"],[6,"One"],[6,"Orig"],[6,"Outer"],[6,"POrd"],[6,"PntAsVec"],[6,"RMul"],[6,"Rotate"],[6,"Rotation"],[6,"RotationMatrix"],[6,"RotationWithTranslation"],[6,"Row"],[6,"ScalarAdd"],[6,"ScalarSub"],[6,"ScalarMul"],[6,"ScalarDiv"],[6,"Shape"],[6,"ToHomogeneous"],[6,"Transform"],[6,"Transformation"],[6,"Translate"],[6,"Translation"],[6,"Transpose"],[6,"UniformSphereSample"],[6,"VecAsPnt"],[6,"Zero"]]};

searchIndex['rustc-serialize'] = {"items":[[0,"","rustc-serialize","Support code for encoding and decoding types."],[10,"encode","collections::string","",0],[10,"decode","","",0],[10,"encode","alloc::boxed","",1],[10,"decode","","",1],[10,"decode","","",1],[10,"encode","alloc::rc","",2],[10,"decode","","",2],[10,"encode","collections::vec","",3],[10,"decode","","",3],[10,"encode","core::option","",4],[10,"decode","","",4],[10,"encode","std::path::posix","",5],[10,"decode","","",5],[10,"encode","std::path::windows","",6],[10,"decode","","",6],[10,"encode","core::cell","",7],[10,"decode","","",7],[10,"encode","","",8],[10,"decode","","",8],[10,"encode","alloc::arc","",9],[10,"decode","","",9],[10,"encode","collections::dlist","",10],[10,"decode","","",10],[10,"encode","collections::ring_buf","",11],[10,"decode","","",11],[10,"encode","collections::btree::map","",12],[10,"decode","","",12],[10,"encode","collections::btree::set","",13],[10,"decode","","",13],[10,"encode","std::collections::hash::map","",14],[10,"decode","","",14],[10,"encode","std::collections::hash::set","",15],[10,"decode","","",15],[10,"encode","collections::vec_map","",16],[10,"decode","","",16],[0,"base64","rustc-serialize","Base64 binary-to-text encoding"],[1,"Config","rustc-serialize::base64","Contains configuration parameters for `to_base64`."],[11,"char_set","","Character set to use",17],[11,"newline","","Newline to use",17],[11,"pad","","True to pad output with `=` characters",17],[11,"line_length","","`Some(len)` to wrap lines at `len`, `None` to disable line wrapping",17],[2,"CharacterSet","","Available encoding character sets"],[12,"Standard","","The standard character set (uses `+` and `/`)",18],[12,"UrlSafe","","The URL safe character set (uses `-` and `_`)",18],[2,"Newline","","Available newline types"],[12,"LF","","A linefeed (i.e. Unix-style newline)",19],[12,"CRLF","","A carriage return and a linefeed (i.e. Windows-style newline)",19],[2,"FromBase64Error","","Errors that can occur when decoding a base64 encoded string"],[12,"InvalidBase64Byte","","The input contained a character not part of the base64 format",20],[12,"InvalidBase64Length","","The input had an invalid length",20],[5,"STANDARD","","Configuration for RFC 4648 standard base64 encoding"],[5,"URL_SAFE","","Configuration for RFC 4648 base64url encoding"],[5,"MIME","","Configuration for RFC 2045 MIME base64 encoding"],[6,"ToBase64","","A trait for converting a value to base64 encoding."],[9,"to_base64","","Converts the value of `self` to a base64 value following the specified\nformat configuration, returning the owned string.",21],[6,"FromBase64","","A trait for converting from base64 encoded values."],[9,"from_base64","","Converts the value of `self`, interpreted as base64 encoded data, into\nan owned vector of bytes, returning the vector.",22],[10,"fmt","","",20],[10,"description","","",20],[10,"detail","","",20],[0,"hex","rustc-serialize","Hex binary-to-text encoding"],[2,"FromHexError","rustc-serialize::hex","Errors that can occur when decoding a hex encoded string"],[12,"InvalidHexCharacter","","The input contained a character not part of the hex format",23],[12,"InvalidHexLength","","The input had an invalid length",23],[6,"ToHex","","A trait for converting a value to hexadecimal encoding"],[9,"to_hex","","Converts the value of `self` to a hex value, returning the owned\nstring.",24],[6,"FromHex","","A trait for converting hexadecimal encoded values"],[9,"from_hex","","Converts the value of `self`, interpreted as hexadecimal encoded data,\ninto an owned vector of bytes, returning the vector.",25],[10,"fmt","","",23],[10,"description","","",23],[10,"detail","","",23],[0,"json","rustc-serialize","JSON parsing and serialization"],[1,"PrettyJson","rustc-serialize::json",""],[1,"AsJson","",""],[1,"AsPrettyJson","",""],[1,"Encoder","","A structure for implementing serialization to JSON."],[1,"PrettyEncoder","","Another encoder for JSON, but prints out human-readable JSON instead of\ncompact data"],[1,"Stack","","A Stack represents the current position of the parser in the logical\nstructure of the JSON stream.\nFor example foo.bar[3].x"],[1,"Parser","","A streaming JSON parser implemented as an iterator of JsonEvent, consuming\nan iterator of char."],[1,"Builder","","A Builder consumes a json::Parser to create a generic Json structure."],[1,"Decoder","","A structure to decode JSON to values in rust."],[2,"Json","","Represents a json value"],[12,"I64","","",26],[12,"U64","","",26],[12,"F64","","",26],[12,"String","","",26],[12,"Boolean","","",26],[12,"Array","","",26],[12,"Object","","",26],[12,"Null","","",26],[2,"ErrorCode","","The errors that can arise while parsing a JSON stream."],[12,"InvalidSyntax","","",27],[12,"InvalidNumber","","",27],[12,"EOFWhileParsingObject","","",27],[12,"EOFWhileParsingArray","","",27],[12,"EOFWhileParsingValue","","",27],[12,"EOFWhileParsingString","","",27],[12,"KeyMustBeAString","","",27],[12,"ExpectedColon","","",27],[12,"TrailingCharacters","","",27],[12,"TrailingComma","","",27],[12,"InvalidEscape","","",27],[12,"InvalidUnicodeCodePoint","","",27],[12,"LoneLeadingSurrogateInHexEscape","","",27],[12,"UnexpectedEndOfHexEscape","","",27],[12,"UnrecognizedHex","","",27],[12,"NotFourDigit","","",27],[12,"NotUtf8","","",27],[2,"ParserError","",""],[12,"SyntaxError","","msg, line, col",28],[12,"IoError","","",28],[2,"DecoderError","",""],[12,"ParseError","","",29],[12,"ExpectedError","","",29],[12,"MissingFieldError","","",29],[12,"UnknownVariantError","","",29],[12,"ApplicationError","","",29],[2,"JsonEvent","","The output of the streaming parser."],[12,"ObjectStart","","",30],[12,"ObjectEnd","","",30],[12,"ArrayStart","","",30],[12,"ArrayEnd","","",30],[12,"BooleanValue","","",30],[12,"I64Value","","",30],[12,"U64Value","","",30],[12,"F64Value","","",30],[12,"StringValue","","",30],[12,"NullValue","","",30],[12,"Error","","",30],[2,"StackElement","","StackElements compose a Stack.\nFor example, Key(\"foo\"), Key(\"bar\"), Index(3) and Key(\"x\") are the\nStackElements compositing the stack that represents foo.bar[3].x"],[12,"Index","","",31],[12,"Key","","",31],[3,"error_str","","Returns a readable error string for a given error code."],[3,"decode","","Shortcut function to decode a JSON `&str` into an object"],[3,"encode","","Shortcut function to encode a `T` into a JSON `String`"],[3,"as_json","","Create an `AsJson` wrapper which can be used to print a value as JSON\non-the-fly via `write!`"],[3,"as_pretty_json","","Create an `AsPrettyJson` wrapper which can be used to print a value as JSON\non-the-fly via `write!`"],[4,"Array","",""],[4,"Object","",""],[4,"BuilderError","",""],[4,"EncodeResult","",""],[4,"DecodeResult","",""],[6,"ToJson","","A trait for converting values to JSON"],[9,"to_json","","Converts the value of `self` to an instance of JSON",32],[10,"fmt","","",26],[10,"partial_cmp","","",26],[10,"lt","","",26],[10,"le","","",26],[10,"gt","","",26],[10,"ge","","",26],[10,"eq","","",26],[10,"ne","","",26],[10,"clone","","",26],[10,"eq","","",27],[10,"ne","","",27],[10,"clone","","",27],[10,"fmt","","",28],[10,"eq","","",28],[10,"ne","","",28],[10,"clone","","",28],[10,"fmt","","",29],[10,"eq","","",29],[10,"ne","","",29],[10,"clone","","",29],[10,"fmt","","",27],[10,"description","","",29],[10,"detail","","",29],[10,"new","","Creates a new JSON encoder whose output will be written to the writer\nspecified.",33],[4,"Error","",""],[10,"emit_nil","","",33],[10,"emit_usize","","",33],[10,"emit_u64","","",33],[10,"emit_u32","","",33],[10,"emit_u16","","",33],[10,"emit_u8","","",33],[10,"emit_isize","","",33],[10,"emit_i64","","",33],[10,"emit_i32","","",33],[10,"emit_i16","","",33],[10,"emit_i8","","",33],[10,"emit_bool","","",33],[10,"emit_f64","","",33],[10,"emit_f32","","",33],[10,"emit_char","","",33],[10,"emit_str","","",33],[10,"emit_enum","","",33],[10,"emit_enum_variant","","",33],[10,"emit_enum_variant_arg","","",33],[10,"emit_enum_struct_variant","","",33],[10,"emit_enum_struct_variant_field","","",33],[10,"emit_struct","","",33],[10,"emit_struct_field","","",33],[10,"emit_tuple","","",33],[10,"emit_tuple_arg","","",33],[10,"emit_tuple_struct","","",33],[10,"emit_tuple_struct_arg","","",33],[10,"emit_option","","",33],[10,"emit_option_none","","",33],[10,"emit_option_some","","",33],[10,"emit_seq","","",33],[10,"emit_seq_elt","","",33],[10,"emit_map","","",33],[10,"emit_map_elt_key","","",33],[10,"emit_map_elt_val","","",33],[10,"new","","Creates a new encoder whose output will be written to the specified writer",34],[10,"set_indent","","Set the number of spaces to indent for each level.\nThis is safe to set during encoding.",34],[4,"Error","",""],[10,"emit_nil","","",34],[10,"emit_usize","","",34],[10,"emit_u64","","",34],[10,"emit_u32","","",34],[10,"emit_u16","","",34],[10,"emit_u8","","",34],[10,"emit_isize","","",34],[10,"emit_i64","","",34],[10,"emit_i32","","",34],[10,"emit_i16","","",34],[10,"emit_i8","","",34],[10,"emit_bool","","",34],[10,"emit_f64","","",34],[10,"emit_f32","","",34],[10,"emit_char","","",34],[10,"emit_str","","",34],[10,"emit_enum","","",34],[10,"emit_enum_variant","","",34],[10,"emit_enum_variant_arg","","",34],[10,"emit_enum_struct_variant","","",34],[10,"emit_enum_struct_variant_field","","",34],[10,"emit_struct","","",34],[10,"emit_struct_field","","",34],[10,"emit_tuple","","",34],[10,"emit_tuple_arg","","",34],[10,"emit_tuple_struct","","",34],[10,"emit_tuple_struct_arg","","",34],[10,"emit_option","","",34],[10,"emit_option_none","","",34],[10,"emit_option_some","","",34],[10,"emit_seq","","",34],[10,"emit_seq_elt","","",34],[10,"emit_map","","",34],[10,"emit_map_elt_key","","",34],[10,"emit_map_elt_val","","",34],[10,"encode","","",26],[10,"from_reader","","Decodes a json value from an `&mut io::Reader`",26],[10,"from_str","","Decodes a json value from a string",26],[10,"pretty","","Borrow this json object as a pretty object to generate a pretty\nrepresentation for it via `Show`.",26],[10,"find","","If the Json value is an Object, returns the value associated with the provided key.\nOtherwise, returns None.",26],[10,"find_path","","Attempts to get a nested Json Object for each key in `keys`.\nIf any key is found not to exist, find_path will return None.\nOtherwise, it will return the Json value associated with the final key.",26],[10,"search","","If the Json value is an Object, performs a depth-first search until\na value associated with the provided key is found. If no value is found\nor the Json value is not an Object, returns None.",26],[10,"is_object","","Returns true if the Json value is an Object. Returns false otherwise.",26],[10,"as_object","","If the Json value is an Object, returns the associated BTreeMap.\nReturns None otherwise.",26],[10,"is_array","","Returns true if the Json value is an Array. Returns false otherwise.",26],[10,"as_array","","If the Json value is an Array, returns the associated vector.\nReturns None otherwise.",26],[10,"is_string","","Returns true if the Json value is a String. Returns false otherwise.",26],[10,"as_string","","If the Json value is a String, returns the associated str.\nReturns None otherwise.",26],[10,"is_number","","Returns true if the Json value is a Number. Returns false otherwise.",26],[10,"is_i64","","Returns true if the Json value is a i64. Returns false otherwise.",26],[10,"is_u64","","Returns true if the Json value is a u64. Returns false otherwise.",26],[10,"is_f64","","Returns true if the Json value is a f64. Returns false otherwise.",26],[10,"as_i64","","If the Json value is a number, return or cast it to a i64.\nReturns None otherwise.",26],[10,"as_u64","","If the Json value is a number, return or cast it to a u64.\nReturns None otherwise.",26],[10,"as_f64","","If the Json value is a number, return or cast it to a f64.\nReturns None otherwise.",26],[10,"is_boolean","","Returns true if the Json value is a Boolean. Returns false otherwise.",26],[10,"as_boolean","","If the Json value is a Boolean, returns the associated bool.\nReturns None otherwise.",26],[10,"is_null","","Returns true if the Json value is a Null. Returns false otherwise.",26],[10,"as_null","","If the Json value is a Null, returns ().\nReturns None otherwise.",26],[4,"Output","",""],[10,"index","","",26],[4,"Output","",""],[10,"index","","",26],[10,"fmt","","",30],[10,"clone","","",30],[10,"eq","","",30],[10,"ne","","",30],[10,"fmt","","",31],[10,"clone","","",31],[10,"eq","","",31],[10,"ne","","",31],[10,"new","","",35],[10,"len","","Returns The number of elements in the Stack.",35],[10,"is_empty","","Returns true if the stack is empty.",35],[10,"get","","Provides access to the StackElement at a given index.\nlower indices are at the bottom of the stack while higher indices are\nat the top.",35],[10,"is_equal_to","","Compares this stack with an array of StackElements.",35],[10,"starts_with","","Returns true if the bottom-most elements of this stack are the same as\nthe ones passed as parameter.",35],[10,"ends_with","","Returns true if the top-most elements of this stack are the same as\nthe ones passed as parameter.",35],[10,"top","","Returns the top-most element (if any).",35],[4,"Item","",""],[10,"next","","",36],[10,"new","","Creates the JSON parser.",36],[10,"stack","","Provides access to the current position in the logical structure of the\nJSON stream.",36],[10,"new","","Create a JSON Builder.",37],[10,"build","","",37],[10,"new","","Creates a new decoder instance for decoding the specified JSON value.",38],[4,"Error","",""],[10,"read_nil","","",38],[10,"read_usize","","",38],[10,"read_u8","","",38],[10,"read_u16","","",38],[10,"read_u32","","",38],[10,"read_u64","","",38],[10,"read_isize","","",38],[10,"read_i8","","",38],[10,"read_i16","","",38],[10,"read_i32","","",38],[10,"read_i64","","",38],[10,"read_f32","","",38],[10,"read_f64","","",38],[10,"read_bool","","",38],[10,"read_char","","",38],[10,"read_str","","",38],[10,"read_enum","","",38],[10,"read_enum_variant","","",38],[10,"read_enum_variant_arg","","",38],[10,"read_enum_struct_variant","","",38],[10,"read_enum_struct_variant_field","","",38],[10,"read_struct","","",38],[10,"read_struct_field","","",38],[10,"read_tuple","","",38],[10,"read_tuple_arg","","",38],[10,"read_tuple_struct","","",38],[10,"read_tuple_struct_arg","","",38],[10,"read_option","","",38],[10,"read_seq","","",38],[10,"read_seq_elt","","",38],[10,"read_map","","",38],[10,"read_map_elt_key","","",38],[10,"read_map_elt_val","","",38],[10,"error","","",38],[10,"to_json","","",26],[10,"to_json","collections::string","",0],[10,"to_json","collections::vec","",3],[10,"to_json","collections::btree::map","",12],[10,"to_json","std::collections::hash::map","",14],[10,"to_json","core::option","",4],[10,"fmt","rustc-serialize::json","Encodes a json value into a string",26],[10,"fmt","","Encodes a json value into a string",39],[10,"fmt","","Encodes a json value into a string",40],[10,"indent","","Set the indentation level for the emitted JSON",41],[10,"fmt","","Encodes a json value into a string",41],[10,"from_str","","",26],[10,"encode","collections::string","",0],[10,"decode","","",0],[10,"encode","alloc::boxed","",1],[10,"decode","","",1],[10,"decode","","",1],[10,"encode","alloc::rc","",2],[10,"decode","","",2],[10,"encode","collections::vec","",3],[10,"decode","","",3],[10,"encode","core::option","",4],[10,"decode","","",4],[10,"encode","std::path::posix","",5],[10,"decode","","",5],[10,"encode","std::path::windows","",6],[10,"decode","","",6],[10,"encode","core::cell","",7],[10,"decode","","",7],[10,"encode","","",8],[10,"decode","","",8],[10,"encode","alloc::arc","",9],[10,"decode","","",9],[6,"Decoder","rustc-serialize",""],[17,"Error","rustc-serialize::Decoder",""],[9,"read_nil","rustc-serialize","",42],[9,"read_usize","","",42],[9,"read_u64","","",42],[9,"read_u32","","",42],[9,"read_u16","","",42],[9,"read_u8","","",42],[9,"read_isize","","",42],[9,"read_i64","","",42],[9,"read_i32","","",42],[9,"read_i16","","",42],[9,"read_i8","","",42],[9,"read_bool","","",42],[9,"read_f64","","",42],[9,"read_f32","","",42],[9,"read_char","","",42],[9,"read_str","","",42],[9,"read_enum","","",42],[9,"read_enum_variant","","",42],[9,"read_enum_variant_arg","","",42],[9,"read_enum_struct_variant","","",42],[9,"read_enum_struct_variant_field","","",42],[9,"read_struct","","",42],[9,"read_struct_field","","",42],[9,"read_tuple","","",42],[9,"read_tuple_arg","","",42],[9,"read_tuple_struct","","",42],[9,"read_tuple_struct_arg","","",42],[9,"read_option","","",42],[9,"read_seq","","",42],[9,"read_seq_elt","","",42],[9,"read_map","","",42],[9,"read_map_elt_key","","",42],[9,"read_map_elt_val","","",42],[9,"error","","",42],[6,"Encoder","",""],[17,"Error","rustc-serialize::Encoder",""],[9,"emit_nil","rustc-serialize","",43],[9,"emit_usize","","",43],[9,"emit_u64","","",43],[9,"emit_u32","","",43],[9,"emit_u16","","",43],[9,"emit_u8","","",43],[9,"emit_isize","","",43],[9,"emit_i64","","",43],[9,"emit_i32","","",43],[9,"emit_i16","","",43],[9,"emit_i8","","",43],[9,"emit_bool","","",43],[9,"emit_f64","","",43],[9,"emit_f32","","",43],[9,"emit_char","","",43],[9,"emit_str","","",43],[9,"emit_enum","","",43],[9,"emit_enum_variant","","",43],[9,"emit_enum_variant_arg","","",43],[9,"emit_enum_struct_variant","","",43],[9,"emit_enum_struct_variant_field","","",43],[9,"emit_struct","","",43],[9,"emit_struct_field","","",43],[9,"emit_tuple","","",43],[9,"emit_tuple_arg","","",43],[9,"emit_tuple_struct","","",43],[9,"emit_tuple_struct_arg","","",43],[9,"emit_option","","",43],[9,"emit_option_none","","",43],[9,"emit_option_some","","",43],[9,"emit_seq","","",43],[9,"emit_seq_elt","","",43],[9,"emit_map","","",43],[9,"emit_map_elt_key","","",43],[9,"emit_map_elt_val","","",43],[6,"Decodable","",""],[9,"decode","","",44],[6,"Encodable","",""],[9,"encode","","",45],[6,"DecoderHelpers","",""],[9,"read_to_vec","","",46],[6,"EncoderHelpers","",""],[9,"emit_from_vec","","",47]],"paths":[[1,"String"],[1,"Box"],[1,"Rc"],[1,"Vec"],[2,"Option"],[1,"Path"],[1,"Path"],[1,"Cell"],[1,"RefCell"],[1,"Arc"],[1,"DList"],[1,"RingBuf"],[1,"BTreeMap"],[1,"BTreeSet"],[1,"HashMap"],[1,"HashSet"],[1,"VecMap"],[1,"Config"],[2,"CharacterSet"],[2,"Newline"],[2,"FromBase64Error"],[6,"ToBase64"],[6,"FromBase64"],[2,"FromHexError"],[6,"ToHex"],[6,"FromHex"],[2,"Json"],[2,"ErrorCode"],[2,"ParserError"],[2,"DecoderError"],[2,"JsonEvent"],[2,"StackElement"],[6,"ToJson"],[1,"Encoder"],[1,"PrettyEncoder"],[1,"Stack"],[1,"Parser"],[1,"Builder"],[1,"Decoder"],[1,"PrettyJson"],[1,"AsJson"],[1,"AsPrettyJson"],[6,"Decoder"],[6,"Encoder"],[6,"Decodable"],[6,"Encodable"],[6,"DecoderHelpers"],[6,"EncoderHelpers"]]};

initSearch(searchIndex);
